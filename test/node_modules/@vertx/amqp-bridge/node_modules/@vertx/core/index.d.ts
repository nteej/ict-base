/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

export interface Handler<T> {
  handle(arg0: T) : void;
}

export interface AsyncResult<T> {
  succeeded() : boolean;
  failed() : boolean;
  cause() : Throwable | null;
  result() : T | null;
}

/**
 * Represents a file on the file-system which can be read from, or written to asynchronously.
 * <p>
 * This class also implements {@link ReadStream} and
 * {@link WriteStream}. This allows the data to be pumped to and from
 * other streams, e.g. an {@link HttpClientRequest} instance,
 * using the {@link Pump} class
 */
export abstract class AsyncFile implements ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link AsyncFile#end} but writes some data to the stream before ending.
   */
  end(data: Buffer) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link AsyncFile#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : AsyncFile;

  pause() : AsyncFile;

  resume() : AsyncFile;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : AsyncFile;

  write(data: Buffer) : AsyncFile;

  /**
   * Same as {@link AsyncFile#write} but with an <code>handler</code> called when the operation completes
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  setWriteQueueMaxSize(maxSize: number) : AsyncFile;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : AsyncFile;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : AsyncFile;

  fetch(amount: number) : AsyncFile;

  /**
   * Close the file, see {@link AsyncFile#close}.
   */
  end() : void;

  /**
   * Close the file, see {@link AsyncFile#close}.
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the file. The actual close happens asynchronously.
   */
  close() : void;

  /**
   * Close the file. The actual close happens asynchronously.
   * The handler will be called when the close is complete, or an error occurs.
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Write a {@link Buffer} to the file at position <code>position</code> in the file, asynchronously.
   * <p>
   * If <code>position</code> lies outside of the current size
   * of the file, the file will be enlarged to encompass it.
   * <p>
   * When multiple writes are invoked on the same file
   * there are no guarantees as to order in which those writes actually occur
   * <p>
   * The handler will be called when the write is complete, or if an error occurs.
   */
  write(buffer: Buffer, position: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  /**
   * Reads <code>length</code> bytes of data from the file at position <code>position</code> in the file, asynchronously.
   * <p>
   * The read data will be written into the specified <code>Buffer buffer</code> at position <code>offset</code>.
   * <p>
   * If data is read past the end of the file then zero bytes will be read.<p>
   * When multiple reads are invoked on the same file there are no guarantees as to order in which those reads actually occur.
   * <p>
   * The handler will be called when the close is complete, or if an error occurs.
   */
  read(buffer: Buffer, offset: number, position: number, length: number, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : AsyncFile;

  /**
   * Flush any writes made to this file to underlying persistent storage.
   * <p>
   * If the file was opened with <code>flush</code> set to <code>true</code> then calling this method will have no effect.
   * <p>
   * The actual flush will happen asynchronously.
   */
  flush() : AsyncFile;

  /**
   * Same as {@link AsyncFile#flush} but the handler will be called when the flush is complete or if an error occurs
   */
  flush(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : AsyncFile;

  /**
   * Sets the position from which data will be read from when using the file as a {@link ReadStream}.
   */
  setReadPos(readPos: number) : AsyncFile;

  /**
   * Sets the number of bytes that will be read when using the file as a {@link ReadStream}.
   */
  setReadLength(readLength: number) : AsyncFile;

  /**
   * Sets the position from which data will be written when using the file as a {@link WriteStream}.
   */
  setWritePos(writePos: number) : AsyncFile;

  /**
   */
  getWritePos() : number;

  /**
   * Sets the buffer size that will be used to read the data from the file. Changing this value will impact how much
   * the data will be read at a time from the file system.
   */
  setReadBufferSize(readBufferSize: number) : AsyncFile;
}

/**
 * An asynchronous map.
 * <p>
 * {@link AsyncMap} does <em>not</em> allow <code>null</code> to be used as a key or value.
 */
export abstract class AsyncMap<K, V> {
  /**
   * Get a value from the map, asynchronously.
   */
  get(k: K, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Put a value in the map, asynchronously.
   */
  put(k: K, v: V, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Like {@link AsyncMap#put} but specifying a time to live for the entry. Entry will expire and get evicted after the
   * ttl.
   */
  put(k: K, v: V, ttl: number, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Put the entry only if there is no entry with the key already present. If key already present then the existing
   * value will be returned to the handler, otherwise null.
   */
  putIfAbsent(k: K, v: V, completionHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Link {@link AsyncMap#putIfAbsent} but specifying a time to live for the entry. Entry will expire and get evicted
   * after the ttl.
   */
  putIfAbsent(k: K, v: V, ttl: number, completionHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Remove a value from the map, asynchronously.
   */
  remove(k: K, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Remove a value from the map, only if entry already exists with same value.
   */
  removeIfPresent(k: K, v: V, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;

  /**
   * Replace the entry only if it is currently mapped to some value
   */
  replace(k: K, v: V, resultHandler: ((res: AsyncResult<V>) => void) | Handler<AsyncResult<V>>) : void;

  /**
   * Replace the entry only if it is currently mapped to a specific value
   */
  replaceIfPresent(k: K, oldValue: V, newValue: V, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;

  /**
   * Clear all entries in the map
   */
  clear(resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Provide the number of entries in the map
   */
  size(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;
}

/**
 * Most data is shuffled around inside Vert.x using buffers.
 * <p>
 * A buffer is a sequence of zero or more bytes that can read from or written to and which expands automatically as
 * necessary to accommodate any bytes written to it. You can perhaps think of a buffer as smart byte array.
 * <p>
 * Please consult the documentation for more information on buffers.
 */
export abstract class Buffer {
  /**
   * Create a new, empty buffer.
   */
  static buffer() : Buffer;

  /**
   * Create a new buffer given the initial size hint.
   * <p>
   * If you know the buffer will require a certain size, providing the hint can prevent unnecessary re-allocations
   * as the buffer is written to and resized.
   */
  static buffer(initialSizeHint: number) : Buffer;

  /**
   * Create a new buffer from a string. The string will be UTF-8 encoded into the buffer.
   */
  static buffer(string: string) : Buffer;

  /**
   * Create a new buffer from a string and using the specified encoding.
   * The string will be encoded into the buffer using the specified encoding.
   */
  static buffer(string: string, enc: string) : Buffer;

  /**
   * Returns a <code>String</code> representation of the Buffer with the <code>UTF-8</code>encoding
   */
  toString() : string;

  /**
   * Returns a <code>String</code> representation of the Buffer with the encoding specified by <code>enc</code>
   */
  toString(enc: string) : string;

  /**
   * Returns a Json object representation of the Buffer.
   */
  toJsonObject() : { [key: string]: any };

  /**
   * Returns a Json array representation of the Buffer.
   */
  toJsonArray() : any[];

  /**
   * Returns a Json representation of the Buffer.
   */
  toJson() : any;

  /**
   * Returns the <code>byte</code> at position <code>pos</code> in the Buffer.
   */
  getByte(pos: number) : number;

  /**
   * Returns the unsigned <code>byte</code> at position <code>pos</code> in the Buffer, as a <code>short</code>.
   */
  getUnsignedByte(pos: number) : number;

  /**
   * Returns the <code>int</code> at position <code>pos</code> in the Buffer.
   */
  getInt(pos: number) : number;

  /**
   * Gets a 32-bit integer at the specified absolute <code>index</code> in this buffer with Little Endian Byte Order.
   */
  getIntLE(pos: number) : number;

  /**
   * Returns the unsigned <code>int</code> at position <code>pos</code> in the Buffer, as a <code>long</code>.
   */
  getUnsignedInt(pos: number) : number;

  /**
   * Returns the unsigned <code>int</code> at position <code>pos</code> in the Buffer, as a <code>long</code> in Little Endian Byte Order.
   */
  getUnsignedIntLE(pos: number) : number;

  /**
   * Returns the <code>long</code> at position <code>pos</code> in the Buffer.
   */
  getLong(pos: number) : number;

  /**
   * Gets a 64-bit long integer at the specified absolute <code>index</code> in this buffer in Little Endian Byte Order.
   */
  getLongLE(pos: number) : number;

  /**
   * Returns the <code>double</code> at position <code>pos</code> in the Buffer.
   */
  getDouble(pos: number) : number;

  /**
   * Returns the <code>float</code> at position <code>pos</code> in the Buffer.
   */
  getFloat(pos: number) : number;

  /**
   * Returns the <code>short</code> at position <code>pos</code> in the Buffer.
   */
  getShort(pos: number) : number;

  /**
   * Gets a 16-bit short integer at the specified absolute <code>index</code> in this buffer in Little Endian Byte Order.
   */
  getShortLE(pos: number) : number;

  /**
   * Returns the unsigned <code>short</code> at position <code>pos</code> in the Buffer, as an <code>int</code>.
   */
  getUnsignedShort(pos: number) : number;

  /**
   * Gets an unsigned 16-bit short integer at the specified absolute <code>index</code> in this buffer in Little Endian Byte Order.
   */
  getUnsignedShortLE(pos: number) : number;

  /**
   * Gets a 24-bit medium integer at the specified absolute <code>index</code> in this buffer.
   */
  getMedium(pos: number) : number;

  /**
   * Gets a 24-bit medium integer at the specified absolute <code>index</code> in this buffer in the Little Endian Byte Order.
   */
  getMediumLE(pos: number) : number;

  /**
   * Gets an unsigned 24-bit medium integer at the specified absolute <code>index</code> in this buffer.
   */
  getUnsignedMedium(pos: number) : number;

  /**
   * Gets an unsigned 24-bit medium integer at the specified absolute <code>index</code> in this buffer in Little Endian Byte Order.
   */
  getUnsignedMediumLE(pos: number) : number;

  /**
   * Returns a copy of a sub-sequence the Buffer as a {@link Buffer} starting at position <code>start</code>
   * and ending at position <code>end - 1</code>
   */
  getBuffer(start: number, end: number) : Buffer;

  /**
   * Returns a copy of a sub-sequence the Buffer as a <code>String</code> starting at position <code>start</code>
   * and ending at position <code>end - 1</code> interpreted as a String in the specified encoding
   */
  getString(start: number, end: number, enc: string) : string;

  /**
   * Returns a copy of a sub-sequence the Buffer as a <code>String</code> starting at position <code>start</code>
   * and ending at position <code>end - 1</code> interpreted as a String in UTF-8 encoding
   */
  getString(start: number, end: number) : string;

  /**
   * Appends the specified <code>Buffer</code> to the end of this Buffer. The buffer will expand as necessary to accommodate
   * any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendBuffer(buff: Buffer) : Buffer;

  /**
   * Appends the specified <code>Buffer</code> starting at the <code>offset</code> using <code>len</code> to the end of this Buffer. The buffer will expand as necessary to accommodate
   * any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendBuffer(buff: Buffer, offset: number, len: number) : Buffer;

  /**
   * Appends the specified <code>byte</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendByte(b: number) : Buffer;

  /**
   * Appends the specified unsigned <code>byte</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendUnsignedByte(b: number) : Buffer;

  /**
   * Appends the specified <code>int</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendInt(i: number) : Buffer;

  /**
   * Appends the specified <code>int</code> to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendIntLE(i: number) : Buffer;

  /**
   * Appends the specified unsigned <code>int</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendUnsignedInt(i: number) : Buffer;

  /**
   * Appends the specified unsigned <code>int</code> to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendUnsignedIntLE(i: number) : Buffer;

  /**
   * Appends the specified 24bit <code>int</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendMedium(i: number) : Buffer;

  /**
   * Appends the specified 24bit <code>int</code> to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendMediumLE(i: number) : Buffer;

  /**
   * Appends the specified <code>long</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendLong(l: number) : Buffer;

  /**
   * Appends the specified <code>long</code> to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendLongLE(l: number) : Buffer;

  /**
   * Appends the specified <code>short</code> to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendShort(s: number) : Buffer;

  /**
   * Appends the specified <code>short</code> to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendShortLE(s: number) : Buffer;

  /**
   * Appends the specified unsigned <code>short</code> to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendUnsignedShort(s: number) : Buffer;

  /**
   * Appends the specified unsigned <code>short</code> to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendUnsignedShortLE(s: number) : Buffer;

  /**
   * Appends the specified <code>float</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendFloat(f: number) : Buffer;

  /**
   * Appends the specified <code>double</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendDouble(d: number) : Buffer;

  /**
   * Appends the specified <code>String</code> to the end of the Buffer with the encoding as specified by <code>enc</code>.<p>
   * The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.<p>
   */
  appendString(str: string, enc: string) : Buffer;

  /**
   * Appends the specified <code>String str</code> to the end of the Buffer with UTF-8 encoding.<p>
   * The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together<p>
   */
  appendString(str: string) : Buffer;

  /**
   * Sets the <code>byte</code> at position <code>pos</code> in the Buffer to the value <code>b</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setByte(pos: number, b: number) : Buffer;

  /**
   * Sets the unsigned <code>byte</code> at position <code>pos</code> in the Buffer to the value <code>b</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setUnsignedByte(pos: number, b: number) : Buffer;

  /**
   * Sets the <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setInt(pos: number, i: number) : Buffer;

  /**
   * Sets the <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code> in the Little Endian Byte Order.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setIntLE(pos: number, i: number) : Buffer;

  /**
   * Sets the unsigned <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setUnsignedInt(pos: number, i: number) : Buffer;

  /**
   * Sets the unsigned <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code> in the Little Endian Byte Order.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setUnsignedIntLE(pos: number, i: number) : Buffer;

  /**
   * Sets the 24bit <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setMedium(pos: number, i: number) : Buffer;

  /**
   * Sets the 24bit <code>int</code> at position <code>pos</code> in the Buffer to the value <code>i</code>. in the Little Endian Byte Order<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setMediumLE(pos: number, i: number) : Buffer;

  /**
   * Sets the <code>long</code> at position <code>pos</code> in the Buffer to the value <code>l</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setLong(pos: number, l: number) : Buffer;

  /**
   * Sets the <code>long</code> at position <code>pos</code> in the Buffer to the value <code>l</code> in the Little Endian Byte Order.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setLongLE(pos: number, l: number) : Buffer;

  /**
   * Sets the <code>double</code> at position <code>pos</code> in the Buffer to the value <code>d</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setDouble(pos: number, d: number) : Buffer;

  /**
   * Sets the <code>float</code> at position <code>pos</code> in the Buffer to the value <code>f</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setFloat(pos: number, f: number) : Buffer;

  /**
   * Sets the <code>short</code> at position <code>pos</code> in the Buffer to the value <code>s</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setShort(pos: number, s: number) : Buffer;

  /**
   * Sets the <code>short</code> at position <code>pos</code> in the Buffer to the value <code>s</code> in the Little Endian Byte Order.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setShortLE(pos: number, s: number) : Buffer;

  /**
   * Sets the unsigned <code>short</code> at position <code>pos</code> in the Buffer to the value <code>s</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setUnsignedShort(pos: number, s: number) : Buffer;

  /**
   * Sets the unsigned <code>short</code> at position <code>pos</code> in the Buffer to the value <code>s</code> in the Little Endian Byte Order.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setUnsignedShortLE(pos: number, s: number) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the bytes represented by the <code>Buffer b</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setBuffer(pos: number, b: Buffer) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the bytes represented by the <code>Buffer b</code> on the given <code>offset</code> and <code>len</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setBuffer(pos: number, b: Buffer, offset: number, len: number) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the value of <code>str</code> encoded in UTF-8.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setString(pos: number, str: string) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the value of <code>str</code> encoded in encoding <code>enc</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setString(pos: number, str: string, enc: string) : Buffer;

  /**
   * Returns the length of the buffer, measured in bytes.
   * All positions are indexed from zero.
   */
  length() : number;

  /**
   * Returns a copy of the entire Buffer.
   */
  copy() : Buffer;

  /**
   * Returns a slice of this buffer. Modifying the content
   * of the returned buffer or this buffer affects each other's content
   * while they maintain separate indexes and marks.
   */
  slice() : Buffer;

  /**
   * Returns a slice of this buffer. Modifying the content
   * of the returned buffer or this buffer affects each other's content
   * while they maintain separate indexes and marks.
   */
  slice(start: number, end: number) : Buffer;

  /**
   * Create a new buffer from a byte[]. The byte[] will be copied to form the buffer.
   */
  static buffer(bytes: number[]) : Buffer;

  /**
   * <p>
   * Create a new buffer from a Netty <code>ByteBuf</code>.
   * <i>Note that</i> the returned buffer is backed by given Netty ByteBuf,
   * so changes in the returned buffer are reflected in given Netty ByteBuf, and vice-versa.
   * </p>
   * <p>
   * For example, both buffers in the code below share their data:
   * </p>
   * <pre>
   *   Buffer src = Buffer.buffer();
   *   Buffer clone = Buffer.buffer(src.getByteBuf());
   * </pre>
   */
  static buffer(byteBuf: any /* io.netty.buffer.ByteBuf */) : Buffer;

  /**
   * Returns a <code>String</code> representation of the Buffer with the encoding specified by <code>enc</code>
   */
  toString(enc: any /* java.nio.charset.Charset */) : string;

  /**
   * Returns a copy of the entire Buffer as a <code>byte[]</code>
   */
  getBytes() : number[];

  /**
   * Returns a copy of a sub-sequence the Buffer as a <code>byte[]</code> starting at position <code>start</code>
   * and ending at position <code>end - 1</code>
   */
  getBytes(start: number, end: number) : number[];

  /**
   * Transfers the content of the Buffer into a <code>byte[]</code>.
   */
  getBytes(dst: number[]) : Buffer;

  /**
   * Transfers the content of the Buffer into a <code>byte[]</code> at the specific destination.
   */
  getBytes(dst: number[], dstIndex: number) : Buffer;

  /**
   * Transfers the content of the Buffer starting at position <code>start</code> and ending at position <code>end - 1</code>
   * into a <code>byte[]</code>.
   */
  getBytes(start: number, end: number, dst: number[]) : Buffer;

  /**
   * Transfers the content of the Buffer starting at position <code>start</code> and ending at position <code>end - 1</code>
   * into a <code>byte[]</code> at the specific destination.
   */
  getBytes(start: number, end: number, dst: number[], dstIndex: number) : Buffer;

  /**
   * Appends the specified <code>byte[]</code> to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendBytes(bytes: number[]) : Buffer;

  /**
   * Appends the specified number of bytes from <code>byte[]</code> to the end of the Buffer, starting at the given offset.
   * The buffer will expand as necessary to accommodate any bytes written.<p>
   * Returns a reference to <code>this</code> so multiple operations can be appended together.
   */
  appendBytes(bytes: number[], offset: number, len: number) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the bytes represented by the <code>ByteBuffer b</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setBytes(pos: number, b: any /* java.nio.ByteBuffer */) : Buffer;

  /**
   * Sets the bytes at position <code>pos</code> in the Buffer to the bytes represented by the <code>byte[] b</code>.<p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setBytes(pos: number, b: number[]) : Buffer;

  /**
   * Sets the given number of bytes at position <code>pos</code> in the Buffer to the bytes represented by the <code>byte[] b</code>.<p></p>
   * The buffer will expand as necessary to accommodate any value written.
   */
  setBytes(pos: number, b: number[], offset: number, len: number) : Buffer;

  /**
   * Returns the Buffer as a Netty <code>ByteBuf</code>.<p>
   * The returned buffer is a duplicate.<p>
   * The returned <code>ByteBuf</code> might have its <code>readerIndex > 0</code>
   * This method is meant for internal use only.<p>
   */
  getByteBuf() : any /* io.netty.buffer.ByteBuf */;
}

import { Option } from './options';
import { Argument } from './options';

/**
 * Interface defining a command-line interface (in other words a command such as 'run', 'ls'...).
 * This interface is polyglot to ease reuse such as in Vert.x Shell.
 * <p/>
 * A command line interface has a name, and defines a set of options and arguments. Options are key-value pair such
 * as <code>-foo=bar</code> or <code>-flag</code>. The supported formats depend on the used parser. Arguments are unlike
 * options raw values. Options are defined using
 * <a href="../../dataobjects.html#Option">Option</a>, while argument are defined using <a href="../../dataobjects.html#Argument">Argument</a>.
 * <p/>
 * Command line interfaces also define a summary and a description. These attributes are used in the usage generation
 * . To disable the help generation, set the <code>hidden</code> attribute to <code>true</code>.
 * <p/>
 * Command Line Interface object does not contains "value", it's a model. It must be evaluated by a
 * parser that returns a {@link CommandLine} object containing the argument and option values.
 */
export abstract class CLI {
  /**
   * Creates an instance of {@link CLI} using the default implementation.
   */
  static create(name: string) : CLI;

  /**
   * Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   */
  parse(arguments: string[]) : CommandLine;

  /**
   * Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   */
  parse(arguments: string[], validate: boolean) : CommandLine;

  /**
   */
  getName() : string;

  /**
   * Sets the name of the CLI.
   */
  setName(name: string) : CLI;

  /**
   */
  getDescription() : string | null;

  setDescription(desc: string) : CLI;

  /**
   */
  getSummary() : string | null;

  /**
   * Sets the summary of the CLI.
   */
  setSummary(summary: string) : CLI;

  /**
   * Checks whether or not the current {@link CLI} instance is hidden.
   */
  isHidden() : boolean;

  /**
   * Sets whether or not the current instance of {@link CLI} must be hidden. Hidden CLI are not listed when
   * displaying usages / help messages. In other words, hidden commands are for power user.
   */
  setHidden(hidden: boolean) : CLI;

  /**
   * Gets the list of options.
   */
  getOptions() : Option[];

  /**
   * Adds an option.
   */
  addOption(option: Option) : CLI;

  /**
   * Adds a set of options. Unlike {@link CLI#setOptions}}, this method does not remove the existing options.
   * The given list is appended to the existing list.
   */
  addOptions(options: Option[]) : CLI;

  /**
   * Sets the list of arguments.
   */
  setOptions(options: Option[]) : CLI;

  /**
   * Gets the list of defined arguments.
   */
  getArguments() : Argument[];

  /**
   * Adds an argument.
   */
  addArgument(arg: Argument) : CLI;

  /**
   * Adds a set of arguments. Unlike {@link CLI#setArguments}, this method does not remove the existing arguments.
   * The given list is appended to the existing list.
   */
  addArguments(args: Argument[]) : CLI;

  /**
   * Sets the list of arguments.
   */
  setArguments(args: Argument[]) : CLI;

  /**
   * Gets an <a href="../../dataobjects.html#Option">Option</a> based on its name (short name, long name or argument name).
   */
  getOption(name: string) : Option | null;

  /**
   * Gets an <a href="../../dataobjects.html#Argument">Argument</a> based on its name (argument name).
   */
  getArgument(name: string) : Argument | null;

  /**
   * Gets an <a href="../../dataobjects.html#Argument">Argument</a> based on its index.
   */
  getArgument(index: number) : Argument | null;

  /**
   * Removes an option identified by its name. This method does nothing if the option cannot be found.
   */
  removeOption(name: string) : CLI;

  /**
   * Removes an argument identified by its index. This method does nothing if the argument cannot be found.
   */
  removeArgument(index: number) : CLI;

  /**
   */
  getPriority() : number;

  /**
   * Sets the priority of the CLI.
   */
  setPriority(priority: number) : CLI;
}

/**
 * The parser transforms a CLI (a model) into an {@link CommandLine}. This {@link CommandLine}
 * has stored the argument and option values. Only  instance of parser should create
 * objects of this type.
 */
export abstract class CommandLine {
  /**
   * Creates a command line object from the {@link CLI}. This object is intended to be used by
   * the parser to set the argument and option values.
   */
  static create(cli: CLI) : CommandLine;

  /**
   */
  cli() : CLI;

  /**
   */
  allArguments() : string[];

  /**
   * Gets the value of an option with the matching name (can be the long name, short name or arg name).
   */
  getOptionValue<T>(name: string) : T | null;

  /**
   * Gets the value of an argument with the matching name (arg name).
   */
  getArgumentValue<T>(name: string) : T | null;

  /**
   * Gets the value of an argument with the given index.
   */
  getArgumentValue<T>(index: number) : T | null;

  /**
   * Gets the value of an option marked as a flag.
   * <p/>
   * Calling this method an a non-flag option throws an IllegalStateException.
   */
  isFlagEnabled(name: string) : boolean;

  /**
   * Checks whether or not the given option has been assigned in the command line.
   */
  isOptionAssigned(option: Option) : boolean;

  /**
   * Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   */
  getRawValues(option: Option) : string[];

  /**
   * Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   */
  getRawValuesForOption(option: Option) : string[];

  /**
   * Gets the raw values of the given argument. Raw values are simple "String", not converted to the argument type.
   */
  getRawValuesForArgument(argument: Argument) : string[];

  /**
   * Gets the raw value of the given option. Raw values are the values as given in the user command line.
   */
  getRawValueForOption(option: Option) : string | null;

  /**
   * Checks whether or not the given option accept more values.
   */
  acceptMoreValues(option: Option) : boolean;

  /**
   * Gets the raw value of the given argument. Raw values are the values as given in the user command line.
   */
  getRawValueForArgument(arg: Argument) : string | null;

  /**
   * Checks whether or not the given argument has been assigned in the command line.
   */
  isArgumentAssigned(arg: Argument) : boolean;

  /**
   * Checks whether or not the given option has been seen in the user command line.
   */
  isSeenInCommandLine(option: Option) : boolean;

  /**
   * Checks whether or not the command line is valid, i.e. all constraints from arguments and options have been
   * satisfied. This method is used when the parser validation is disabled.
   */
  isValid() : boolean;

  /**
   * Checks whether or not the user has passed a "help" option and is asking for help.
   */
  isAskingForHelp() : boolean;
}

/**
 * The composite future wraps a list of [futures] {@link Future}, it is useful when several futures
 * needs to be coordinated.
 * The handlers set for the coordinated futures are overridden by the handler of the composite future.
 */
export abstract class CompositeFuture extends Future<CompositeFuture> {
  /**
   * Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  complete(result: CompositeFuture) : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryComplete(result: CompositeFuture) : boolean;

  /**
   * The result of the operation. This will be null if the operation failed.
   */
  result() : CompositeFuture;

  /**
   * Alias for {@link Future#compose}.
   */
  flatMap<U>(mapper: (arg: CompositeFuture) => Future<U>) : Future<U>;

  /**
   * Compose this future with a <code>mapper</code> function.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) succeeds, the <code>mapper</code> will be called with
   * the completed value and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  compose<U>(mapper: (arg: CompositeFuture) => Future<U>) : Future<U>;

  /**
   * Compose this future with a <code>successMapper</code> and <code>failureMapper</code> functions.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) succeeds, the <code>successMapper</code> will be called with
   * the completed value and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) fails, the <code>failureMapper</code> will be called with
   * the failure and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * If any mapper function throws an exception, the returned future will be failed with this exception.<p>
   */
  compose<U>(successMapper: (arg: CompositeFuture) => Future<U>, failureMapper: (arg: Throwable) => Future<U>) : Future<U>;

  /**
   * Apply a <code>mapper</code> function on this future.<p>
   * <p>
   * When this future succeeds, the <code>mapper</code> will be called with the completed value and this mapper
   * returns a value. This value will complete the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  map<U>(mapper: (arg: CompositeFuture) => U) : Future<U>;

  /**
   */
  completer() : ((res: AsyncResult<CompositeFuture>) => void) | Handler<AsyncResult<CompositeFuture>>;

  /**
   * Handles a failure of this Future by returning the result of another Future.
   * If the mapper fails, then the returned future will be failed with this failure.
   */
  recover(mapper: (arg: Throwable) => Future<CompositeFuture>) : Future<CompositeFuture>;

  /**
   * Apply a <code>mapper</code> function on this future.<p>
   * <p>
   * When this future fails, the <code>mapper</code> will be called with the completed value and this mapper
   * returns a value. This value will complete the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  otherwise(mapper: (arg: Throwable) => CompositeFuture) : Future<CompositeFuture>;

  /**
   * Map the failure of a future to a specific <code>value</code>.<p>
   * <p>
   * When this future fails, this <code>value</code> will complete the future returned by this method call.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future.
   */
  otherwise(value: CompositeFuture) : Future<CompositeFuture>;

  /**
   * Map the failure of a future to <code>null</code>.<p>
   * <p>
   * This is a convenience for <code>future.otherwise((T) null)</code>.<p>
   * <p>
   * When this future fails, the <code>null</code> value will complete the future returned by this method call.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future.
   */
  otherwiseEmpty() : Future<CompositeFuture>;

  /**
   * Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   * <p/>
   * The returned future fails as soon as one of <code>f1</code> or <code>f2</code> fails.
   */
  static all<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#all} but with 3 futures.
   */
  static all<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#all} but with 4 futures.
   */
  static all<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#all} but with 5 futures.
   */
  static all<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#all} but with 6 futures.
   */
  static all<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#all} but with a list of futures.<p>
   *
   * When the list is empty, the returned future will be already completed.
   */
  static all(futures: Future<any>[]) : CompositeFuture;

  /**
   * Return a composite future, succeeded when any futures is succeeded, failed when all futures are failed.
   * <p/>
   * The returned future succeeds as soon as one of <code>f1</code> or <code>f2</code> succeeds.
   */
  static any<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#any} but with 3 futures.
   */
  static any<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#any} but with 4 futures.
   */
  static any<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#any} but with 5 futures.
   */
  static any<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#any} but with 6 futures.
   */
  static any<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#any} but with a list of futures.<p>
   *
   * When the list is empty, the returned future will be already completed.
   */
  static any(futures: Future<any>[]) : CompositeFuture;

  /**
   * Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   * <p/>
   * It always wait until all its futures are completed and will not fail as soon as one of <code>f1</code> or <code>f2</code> fails.
   */
  static join<T1, T2>(f1: Future<T1>, f2: Future<T2>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#join} but with 3 futures.
   */
  static join<T1, T2, T3>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#join} but with 4 futures.
   */
  static join<T1, T2, T3, T4>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#join} but with 5 futures.
   */
  static join<T1, T2, T3, T4, T5>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#join} but with 6 futures.
   */
  static join<T1, T2, T3, T4, T5, T6>(f1: Future<T1>, f2: Future<T2>, f3: Future<T3>, f4: Future<T4>, f5: Future<T5>, f6: Future<T6>) : CompositeFuture;

  /**
   * Like {@link CompositeFuture#join} but with a list of futures.<p>
   *
   * When the list is empty, the returned future will be already completed.
   */
  static join(futures: Future<any>[]) : CompositeFuture;

  setHandler(handler: ((res: AsyncResult<CompositeFuture>) => void) | Handler<AsyncResult<CompositeFuture>>) : Future<CompositeFuture>;

  onComplete(handler: ((res: AsyncResult<CompositeFuture>) => void) | Handler<AsyncResult<CompositeFuture>>) : CompositeFuture;

  onSuccess(handler: ((res: CompositeFuture) => void) | Handler<CompositeFuture>) : CompositeFuture;

  onFailure(handler: ((res: Throwable) => void) | Handler<Throwable>) : CompositeFuture;

  /**
   * Set this instance as result. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  complete() : void;

  /**
   * Try to set this instance as result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryComplete() : boolean;

  /**
   * Returns a cause of a wrapped future
   */
  cause(index?: number) : Throwable;

  /**
   * Returns true if a wrapped future is succeeded
   */
  succeeded(index?: number) : boolean;

  /**
   * Returns true if a wrapped future is failed
   */
  failed(index?: number) : boolean;

  /**
   * Returns true if a wrapped future is completed
   */
  isComplete(index?: number) : boolean;

  /**
   * Returns the result of a wrapped future
   */
  resultAt<T>(index: number) : T;

  /**
   */
  size() : number;
}

/**
 * The execution context of a {@link Handler} execution.
 * <p>
 * When Vert.x provides an event to a handler or calls the start or stop methods of a {@link Verticle},
 * the execution is associated with a <code>Context</code>.
 * <p>
 * Usually a context is an *event-loop context* and is tied to a specific event loop thread. So executions for that
 * context always occur on that exact same event loop thread.
 * <p>
 * In the case of worker verticles and running inline blocking code a worker context will be associated with the execution
 * which will use a thread from the worker thread pool.
 * <p>
 * When a handler is set by a thread associated with a specific context, the Vert.x will guarantee that when that handler
 * is executed, that execution will be associated with the same context.
 * <p>
 * If a handler is set by a thread not associated with a context (i.e. a non Vert.x thread). Then a new context will
 * be created for that handler.
 * <p>
 * In other words, a context is propagated.
 * <p>
 * This means that when a verticle is deployed, any handlers it sets will be associated with the same context - the context
 * of the verticle.
 * <p>
 * This means (in the case of a standard verticle) that the verticle code will always be executed with the exact same
 * thread, so you don't have to worry about multi-threaded acccess to the verticle state and you can code your application
 * as single threaded.
 * <p>
 * This class also allows arbitrary data to be {@link Context#put} and {@link Context#get} on the context so it can be shared easily
 * amongst different handlers of, for example, a verticle instance.
 * <p>
 * This class also provides {@link Context#runOnContext} which allows an action to be executed asynchronously using the same context.
 */
export abstract class Context {
  /**
   * Is the current thread a worker thread?
   * <p>
   * NOTE! This is not always the same as calling {@link Context#isWorkerContext}. If you are running blocking code
   * from an event loop context, then this will return true but {@link Context#isWorkerContext} will return false.
   */
  static isOnWorkerThread() : boolean;

  /**
   * Is the current thread an event thread?
   * <p>
   * NOTE! This is not always the same as calling {@link Context#isEventLoopContext}. If you are running blocking code
   * from an event loop context, then this will return false but {@link Context#isEventLoopContext} will return true.
   */
  static isOnEventLoopThread() : boolean;

  /**
   * Is the current thread a Vert.x thread? That's either a worker thread or an event loop thread
   */
  static isOnVertxThread() : boolean;

  /**
   * Run the specified action asynchronously on the same context, some time after the current execution has completed.
   */
  runOnContext(action: ((res: void) => void) | Handler<void>) : void;

  /**
   * Safely execute some blocking code.
   * <p>
   * Executes the blocking code in the handler <code>blockingCodeHandler</code> using a thread from the worker pool.
   * <p>
   * When the code is complete the handler <code>resultHandler</code> will be called with the result on the original context
   * (e.g. on the original event loop of the caller).
   * <p>
   * A <code>Future</code> instance is passed into <code>blockingCodeHandler</code>. When the blocking code successfully completes,
   * the handler should call the {@link Promise#complete} or {@link Promise#complete} method, or the {@link Promise#fail}
   * method if it failed.
   * <p>
   * The blocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations
   * or polling operations (i.e a thread that spin in a loop polling events in a blocking fashion) are precluded.
   * <p>
   * When the blocking operation lasts more than the 10 seconds, a message will be printed on the console by the
   * blocked thread checker.
   * <p>
   * Long blocking operations should use a dedicated thread managed by the application, which can interact with
   * verticles using the event-bus or {@link Context#runOnContext}
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Invoke {@link Context#executeBlocking} with order = true.
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * If the context is associated with a Verticle deployment, this returns the deployment ID of that deployment.
   */
  deploymentID() : string;

  /**
   * If the context is associated with a Verticle deployment, this returns the configuration that was specified when
   * the verticle was deployed.
   */
  config() : { [key: string]: any } | null;

  /**
   * The process args
   */
  processArgs() : string[];

  /**
   * Is the current context an event loop context?
   * <p>
   * NOTE! when running blocking code using {@link Vertx#executeBlocking} from a
   * standard (not worker) verticle, the context will still an event loop context and this 
   * will return true.
   */
  isEventLoopContext() : boolean;

  /**
   * Is the current context a worker context?
   * <p>
   * NOTE! when running blocking code using {@link Vertx#executeBlocking} from a
   * standard (not worker) verticle, the context will still an event loop context and this 
   * will return false.
   */
  isWorkerContext() : boolean;

  /**
   * Is the current context a multi-threaded worker context?
   */
  isMultiThreadedWorkerContext() : boolean;

  /**
   * Get some data from the context.
   */
  get<T>(key: string) : T;

  /**
   * Put some data in the context.
   * <p>
   * This can be used to share data between different handlers that share a context
   */
  put(key: string, value: any) : void;

  /**
   * Remove some data from the context.
   */
  remove(key: string) : boolean;

  /**
   */
  owner() : Vertx;

  /**
   */
  getInstanceCount() : number;

  /**
   * Set an exception handler called when the context runs an action throwing an uncaught throwable.<p/>
   *
   * When this handler is called, {@link Vertx#currentContext} will return this context.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : Context;

  addCloseHook(hook: (completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) => void) : void;

  removeCloseHook(hook: (completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) => void) : boolean;
}

import { CookieSameSite } from './enums';

/**
 * Represents an HTTP Cookie.
 * <p>
 * All cookies must have a name and a value and can optionally have other fields set such as path, domain, etc.
 */
export abstract class Cookie {
  /**
   * Create a new cookie
   */
  static cookie(name: string, value: string) : Cookie;

  /**
   */
  getName() : string;

  /**
   */
  getValue() : string;

  /**
   * Sets the value of this cookie
   */
  setValue(value: string) : Cookie;

  /**
   * Sets the domain of this cookie
   */
  setDomain(domain: string | null | undefined) : Cookie;

  /**
   */
  getDomain() : string | null;

  /**
   * Sets the path of this cookie.
   */
  setPath(path: string | null | undefined) : Cookie;

  /**
   */
  getPath() : string | null;

  /**
   * Sets the maximum age of this cookie in seconds.
   * If an age of <code>0</code> is specified, this cookie will be
   * automatically removed by browser because it will expire immediately.
   * If MIN_VALUE is specified, this cookie will be removed when the
   * browser is closed.
   * If you don't set this the cookie will be a session cookie and be removed when the browser is closed.
   */
  setMaxAge(maxAge: number) : Cookie;

  /**
   * Sets the security getStatus of this cookie
   */
  setSecure(secure: boolean) : Cookie;

  /**
   */
  isSecure() : boolean;

  /**
   * Determines if this cookie is HTTP only.
   * If set to true, this cookie cannot be accessed by a client
   * side script. However, this works only if the browser supports it.
   * For for information, please look
   * <a href="http://www.owasp.org/index.php/HTTPOnly">here</a>.
   */
  setHttpOnly(httpOnly: boolean) : Cookie;

  /**
   */
  isHttpOnly() : boolean;

  /**
   * Sets the same site of this cookie.
   */
  setSameSite(policy: CookieSameSite) : Cookie;

  /**
   */
  getSameSite() : CookieSameSite | null;

  /**
   * Encode the cookie to a string. This is what is used in the Set-Cookie header
   */
  encode() : string;
}

/**
 * An asynchronous counter that can be used to across the cluster to maintain a consistent count.
 * <p>
 */
export abstract class Counter {
  /**
   * Get the current value of the counter
   */
  get(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Increment the counter atomically and return the new count
   */
  incrementAndGet(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Increment the counter atomically and return the value before the increment.
   */
  getAndIncrement(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Decrement the counter atomically and return the new count
   */
  decrementAndGet(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Add the value to the counter atomically and return the new count
   */
  addAndGet(value: number, resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Add the value to the counter atomically and return the value before the add
   */
  getAndAdd(value: number, resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Set the counter to the specified value only if the current value is the expectec value. This happens
   * atomically.
   */
  compareAndSet(expected: number, value: number, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : void;
}

/**
 * A received datagram packet (UDP) which contains the data and information about the sender of the data itself.
 */
export abstract class DatagramPacket {
  /**
   * Returns the {@link SocketAddress} of the sender that sent
   * this {@link DatagramPacket}.
   */
  sender() : SocketAddress;

  /**
   * Returns the data of the {@link DatagramPacket}
   */
  data() : Buffer;
}

/**
 * A datagram socket can be used to send {@link DatagramPacket}'s to remote datagram servers
 * and receive {@link DatagramPacket}s .
 * <p>
 * Usually you use a datagram socket to send UDP over the wire. UDP is connection-less which means you are not connected
 * to the remote peer in a persistent way. Because of this you have to supply the address and port of the remote peer
 * when sending data.
 * <p>
 * You can send data to ipv4 or ipv6 addresses, which also include multicast addresses.
 * <p>
 * Please consult the documentation for more information on datagram sockets.
 */
export abstract class DatagramSocket implements Measured, ReadStream<DatagramPacket> {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<DatagramPacket>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<DatagramPacket>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<DatagramPacket>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Write the given {@link Buffer} to the {@link SocketAddress}.
   * The {@link Handler} will be notified once the write completes.
   */
  send(packet: Buffer, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Returns a <code>WriteStream<Buffer></code> able to send  to the
   * {@link SocketAddress}.
   */
  sender(port: number, host: string) : WriteStream<Buffer>;

  /**
   * Write the given String to the {@link SocketAddress} using UTF8 encoding.
   * The  will be notified once the write completes.
   */
  send(str: string, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Write the given String to the {@link SocketAddress} using the given encoding.
   * The  will be notified once the write completes.
   */
  send(str: string, enc: string, port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Closes the {@link DatagramSocket} implementation asynchronous
   * and notifies the handler once done.
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Closes the {@link DatagramSocket}. The close itself is asynchronous.
   */
  close() : void;

  /**
   * Return the {@link SocketAddress} to which
   * this {@link DatagramSocket} is bound.
   */
  localAddress() : SocketAddress;

  /**
   * Joins a multicast group and listens for packets send to it.
   * The  is notified once the operation completes.
   */
  listenMulticastGroup(multicastAddress: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Joins a multicast group and listens for packets send to it on the given network interface.
   * The  is notified once the operation completes.
   */
  listenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Leaves a multicast group and stops listening for packets send to it.
   * The  is notified once the operation completes.
   */
  unlistenMulticastGroup(multicastAddress: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Leaves a multicast group and stops listening for packets send to it on the given network interface.
   * The  is notified once the operation completes.
   */
  unlistenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Block the given address for the given multicast address and notifies the  once
   * the operation completes.
   */
  blockMulticastGroup(multicastAddress: string, sourceToBlock: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Block the given address for the given multicast address on the given network interface and notifies
   * the  once the operation completes.
   */
  blockMulticastGroup(multicastAddress: string, networkInterface: string, sourceToBlock: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  /**
   * Start listening on the given port and host. The handler will be called when the socket is listening.
   */
  listen(port: number, host: string, handler: ((res: AsyncResult<DatagramSocket>) => void) | Handler<AsyncResult<DatagramSocket>>) : DatagramSocket;

  pause() : DatagramSocket;

  resume() : DatagramSocket;

  fetch(amount: number) : DatagramSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : DatagramSocket;

  handler(handler: ((res: DatagramPacket) => void) | Handler<DatagramPacket> | null | undefined) : DatagramSocket;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : DatagramSocket;
}

/**
 *
 * Encapsulates a message being delivered by Vert.x as well as providing control over the message delivery.
 * <p/>
 * Used with event bus interceptors.
 */
export abstract class DeliveryContext<T> {
  /**
   */
  message() : Message<T>;

  /**
   * Call the next interceptor
   */
  next() : void;

  /**
   */
  send() : boolean;

  /**
   */
  body() : any;
}

/**
 * Provides a way to asynchronously lookup information from DNS servers.
 * <p>
 * Please consult the documentation for more information on DNS clients.
 */
export abstract class DnsClient {
  /**
   * Try to lookup the A (ipv4) or AAAA (ipv6) record for the given name. The first found will be used.
   */
  lookup(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to lookup the A (ipv4) record for the given name. The first found will be used.
   */
  lookup4(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to lookup the AAAA (ipv6) record for the given name. The first found will be used.
   */
  lookup6(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to resolve all A (ipv4) records for the given name.
   */
  resolveA(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve all AAAA (ipv6) records for the given name.
   */
  resolveAAAA(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the CNAME record for the given name.
   */
  resolveCNAME(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the MX records for the given name.
   */
  resolveMX(name: string, handler: ((res: AsyncResult<MxRecord[]>) => void) | Handler<AsyncResult<MxRecord[]>>) : DnsClient;

  /**
   * Try to resolve the TXT records for the given name.
   */
  resolveTXT(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the PTR record for the given name.
   */
  resolvePTR(name: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;

  /**
   * Try to resolve the NS records for the given name.
   */
  resolveNS(name: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : DnsClient;

  /**
   * Try to resolve the SRV records for the given name.
   */
  resolveSRV(name: string, handler: ((res: AsyncResult<SrvRecord[]>) => void) | Handler<AsyncResult<SrvRecord[]>>) : DnsClient;

  /**
   * Try to do a reverse lookup of an IP address. This is basically the same as doing trying to resolve a PTR record
   * but allows you to just pass in the IP address and not a valid ptr query string.
   */
  reverseLookup(ipaddress: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : DnsClient;
}

import { DeliveryOptions } from './options';

/**
 * A Vert.x event-bus is a light-weight distributed messaging system which allows different parts of your application,
 * or different applications and services to communicate with each in a loosely coupled way.
 * <p>
 * An event-bus supports publish-subscribe messaging, point-to-point messaging and request-response messaging.
 * <p>
 * Message delivery is best-effort and messages can be lost if failure of all or part of the event bus occurs.
 * <p>
 * Please refer to the documentation for more information on the event bus.
 */
export abstract class EventBus implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Sends a message.
   * <p>
   * The message will be delivered to at most one of the handlers registered to the address.
   */
  send(address: string, message: any | null | undefined) : EventBus;

  /**
   * Like  but specifying a <code>replyHandler</code> that will be called if the recipient
   * subsequently replies to the message.
   */
  send<T>(address: string, message: any | null | undefined, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Like  but specifying <code>options</code> that can be used to configure the delivery.
   */
  send(address: string, message: any | null | undefined, options: DeliveryOptions) : EventBus;

  /**
   * Like  but specifying a <code>replyHandler</code> that will be called if the recipient
   * subsequently replies to the message.
   */
  send<T>(address: string, message: any | null | undefined, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Sends a message and and specify a <code>replyHandler</code> that will be called if the recipient
   * subsequently replies to the message.
   * <p>
   * The message will be delivered to at most one of the handlers registered to the address.
   */
  request<T>(address: string, message: any | null | undefined, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Like  but specifying <code>options</code> that can be used to configure the delivery.
   */
  request<T>(address: string, message: any | null | undefined, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<T>>) => void) | Handler<AsyncResult<Message<T>>>) : EventBus;

  /**
   * Publish a message.<p>
   * The message will be delivered to all handlers registered to the address.
   */
  publish(address: string, message: any | null | undefined) : EventBus;

  /**
   * Like  but specifying <code>options</code> that can be used to configure the delivery.
   */
  publish(address: string, message: any | null | undefined, options: DeliveryOptions) : EventBus;

  /**
   * Create a message consumer against the specified address.
   * <p>
   * The returned consumer is not yet registered
   * at the address, registration will be effective when {@link MessageConsumer#handler}
   * is called.
   */
  consumer<T>(address: string) : MessageConsumer<T>;

  /**
   * Create a consumer and register it against the specified address.
   */
  consumer<T>(address: string, handler: ((res: Message<T>) => void) | Handler<Message<T>>) : MessageConsumer<T>;

  /**
   * Like {@link EventBus#consumer} but the address won't be propagated across the cluster.
   */
  localConsumer<T>(address: string) : MessageConsumer<T>;

  /**
   * Like {@link EventBus#consumer} but the address won't be propagated across the cluster.
   */
  localConsumer<T>(address: string, handler: ((res: Message<T>) => void) | Handler<Message<T>>) : MessageConsumer<T>;

  /**
   * Create a message sender against the specified address.
   * <p>
   * The returned sender will invoke the 
   * method when the stream {@link WriteStream#write} method is called with the sender
   * address and the provided data.
   */
  sender<T>(address: string) : MessageProducer<T>;

  /**
   * Like {@link EventBus#sender} but specifying delivery options that will be used for configuring the delivery of
   * the message.
   */
  sender<T>(address: string, options: DeliveryOptions) : MessageProducer<T>;

  /**
   * Create a message publisher against the specified address.
   * <p>
   * The returned publisher will invoke the 
   * method when the stream {@link WriteStream#write} method is called with the publisher
   * address and the provided data.
   */
  publisher<T>(address: string) : MessageProducer<T>;

  /**
   * Like {@link EventBus#publisher} but specifying delivery options that will be used for configuring the delivery of
   * the message.
   */
  publisher<T>(address: string, options: DeliveryOptions) : MessageProducer<T>;

  /**
   * Add an interceptor that will be called whenever a message is sent from Vert.x
   */
  addOutboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Remove an interceptor that was added by {@link EventBus#addOutboundInterceptor}
   */
  removeOutboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Add an interceptor that will be called whenever a message is received by Vert.x
   */
  addInboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Remove an interceptor that was added by {@link EventBus#addInboundInterceptor}
   */
  removeInboundInterceptor<T>(interceptor: ((res: DeliveryContext<T>) => void) | Handler<DeliveryContext<T>>) : EventBus;

  /**
   * Register a message codec.
   * <p>
   * You can register a message codec if you want to send any non standard message across the event bus.
   * E.g. you might want to send POJOs directly across the event bus.
   * <p>
   * To use a message codec for a send, you should specify it in the delivery options.
   */
  registerCodec(codec: any /* io.vertx.core.eventbus.MessageCodec */) : EventBus;

  /**
   * Unregister a message codec.
   * <p>
   */
  unregisterCodec(name: string) : EventBus;
}

/**
 * Represents properties of a file on the file system.
 * <p>
 */
export abstract class FileProps {
  /**
   * The date the file was created
   */
  creationTime() : number;

  /**
   * The date the file was last accessed
   */
  lastAccessTime() : number;

  /**
   * The date the file was last modified
   */
  lastModifiedTime() : number;

  /**
   * Is the file a directory?
   */
  isDirectory() : boolean;

  /**
   * Is the file some other type? (I.e. not a directory, regular file or symbolic link)
   */
  isOther() : boolean;

  /**
   * Is the file a regular file?
   */
  isRegularFile() : boolean;

  /**
   * Is the file a symbolic link?
   */
  isSymbolicLink() : boolean;

  /**
   * The size of the file, in bytes
   */
  size() : number;
}

import { OpenOptions } from './options';
import { CopyOptions } from './options';

/**
 * Contains a broad set of operations for manipulating files on the file system.
 * <p>
 * A (potential) blocking and non blocking version of each operation is provided.
 * <p>
 * The non blocking versions take a handler which is called when the operation completes or an error occurs.
 * <p>
 * The blocking versions are named <code>xxxBlocking</code> and return the results, or throw exceptions directly.
 * In many cases, depending on the operating system and file system some of the potentially blocking operations
 * can return quickly, which is why we provide them, but it's highly recommended that you test how long they take to
 * return in your particular application before using them on an event loop.
 * <p>
 * Please consult the documentation for more information on file system support.
 */
export abstract class FileSystem {
  /**
   * Copy a file from the path <code>from</code> to path <code>to</code>, asynchronously.
   * <p>
   * The copy will fail if the destination already exists.
   */
  copy(from: string, to: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Copy a file from the path <code>from</code> to path <code>to</code>, asynchronously.
   */
  copy(from: string, to: string, options: CopyOptions, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#copy}
   */
  copyBlocking(from: string, to: string) : FileSystem;

  /**
   * Copy a file from the path <code>from</code> to path <code>to</code>, asynchronously.
   * <p>
   * If <code>recursive</code> is <code>true</code> and <code>from</code> represents a directory, then the directory and its contents
   * will be copied recursively to the destination <code>to</code>.
   * <p>
   * The copy will fail if the destination if the destination already exists.
   */
  copyRecursive(from: string, to: string, recursive: boolean, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#copyRecursive}
   */
  copyRecursiveBlocking(from: string, to: string, recursive: boolean) : FileSystem;

  /**
   * Move a file from the path <code>from</code> to path <code>to</code>, asynchronously.
   * <p>
   * The move will fail if the destination already exists.
   */
  move(from: string, to: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Move a file from the path <code>from</code> to path <code>to</code>, asynchronously.
   */
  move(from: string, to: string, options: CopyOptions, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#move}
   */
  moveBlocking(from: string, to: string) : FileSystem;

  /**
   * Truncate the file represented by <code>path</code> to length <code>len</code> in bytes, asynchronously.
   * <p>
   * The operation will fail if the file does not exist or <code>len</code> is less than <code>zero</code>.
   */
  truncate(path: string, len: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#truncate}
   */
  truncateBlocking(path: string, len: number) : FileSystem;

  /**
   * Change the permissions on the file represented by <code>path</code> to <code>perms</code>, asynchronously.
   * <p>
   * The permission String takes the form rwxr-x--- as
   * specified <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   */
  chmod(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of [#chmod(String, String, Handler)] {@link FileSystem}
   */
  chmodBlocking(path: string, perms: string) : FileSystem;

  /**
   * Change the permissions on the file represented by <code>path</code> to <code>perms</code>, asynchronously.<p>
   * The permission String takes the form rwxr-x--- as
   * specified in {<a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>}.
   * <p>
   * If the file is directory then all contents will also have their permissions changed recursively. Any directory permissions will
   * be set to <code>dirPerms</code>, whilst any normal file permissions will be set to <code>perms</code>.
   */
  chmodRecursive(path: string, perms: string, dirPerms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#chmodRecursive}
   */
  chmodRecursiveBlocking(path: string, perms: string, dirPerms: string) : FileSystem;

  /**
   * Change the ownership on the file represented by <code>path</code> to <code>user</code> and {code group}, asynchronously.
   */
  chown(path: string, user: string | null | undefined, group: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of 
   *
   */
  chownBlocking(path: string, user: string | null | undefined, group: string | null | undefined) : FileSystem;

  /**
   * Obtain properties for the file represented by <code>path</code>, asynchronously.
   * <p>
   * If the file is a link, the link will be followed.
   */
  props(path: string, handler: ((res: AsyncResult<FileProps>) => void) | Handler<AsyncResult<FileProps>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#props}
   */
  propsBlocking(path: string) : FileProps;

  /**
   * Obtain properties for the link represented by <code>path</code>, asynchronously.
   * <p>
   * The link will not be followed.
   */
  lprops(path: string, handler: ((res: AsyncResult<FileProps>) => void) | Handler<AsyncResult<FileProps>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#lprops}
   */
  lpropsBlocking(path: string) : FileProps;

  /**
   * Create a hard link on the file system from <code>link</code> to <code>existing</code>, asynchronously.
   */
  link(link: string, existing: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#link}
   */
  linkBlocking(link: string, existing: string) : FileSystem;

  /**
   * Create a symbolic link on the file system from <code>link</code> to <code>existing</code>, asynchronously.
   */
  symlink(link: string, existing: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#link}
   */
  symlinkBlocking(link: string, existing: string) : FileSystem;

  /**
   * Unlinks the link on the file system represented by the path <code>link</code>, asynchronously.
   */
  unlink(link: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#unlink}
   */
  unlinkBlocking(link: string) : FileSystem;

  /**
   * Returns the path representing the file that the symbolic link specified by <code>link</code> points to, asynchronously.
   */
  readSymlink(link: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#readSymlink}
   */
  readSymlinkBlocking(link: string) : string;

  /**
   * Deletes the file represented by the specified <code>path</code>, asynchronously.
   */
  delete(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#delete}
   */
  deleteBlocking(path: string) : FileSystem;

  /**
   * Deletes the file represented by the specified <code>path</code>, asynchronously.
   * <p>
   * If the path represents a directory and <code>recursive = true</code> then the directory and its contents will be
   * deleted recursively.
   */
  deleteRecursive(path: string, recursive: boolean, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#deleteRecursive}
   */
  deleteRecursiveBlocking(path: string, recursive: boolean) : FileSystem;

  /**
   * Create the directory represented by <code>path</code>, asynchronously.
   * <p>
   * The operation will fail if the directory already exists.
   */
  mkdir(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#mkdir}
   */
  mkdirBlocking(path: string) : FileSystem;

  /**
   * Create the directory represented by <code>path</code>, asynchronously.
   * <p>
   * The new directory will be created with permissions as specified by <code>perms</code>.
   * <p>
   * The permission String takes the form rwxr-x--- as specified
   * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * <p>
   * The operation will fail if the directory already exists.
   */
  mkdir(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#mkdir}
   */
  mkdirBlocking(path: string, perms: string) : FileSystem;

  /**
   * Create the directory represented by <code>path</code> and any non existent parents, asynchronously.
   * <p>
   * The operation will fail if the <code>path</code> already exists but is not a directory.
   */
  mkdirs(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#mkdirs}
   */
  mkdirsBlocking(path: string) : FileSystem;

  /**
   * Create the directory represented by <code>path</code> and any non existent parents, asynchronously.
   * <p>
   * The new directory will be created with permissions as specified by <code>perms</code>.
   * <p>
   * The permission String takes the form rwxr-x--- as specified
   * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * <p>
   * The operation will fail if the <code>path</code> already exists but is not a directory.
   */
  mkdirs(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#mkdirs}
   */
  mkdirsBlocking(path: string, perms: string) : FileSystem;

  /**
   * Read the contents of the directory specified by <code>path</code>, asynchronously.
   * <p>
   * The result is an array of String representing the paths of the files inside the directory.
   */
  readDir(path: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#readDir}
   */
  readDirBlocking(path: string) : string[];

  /**
   * Read the contents of the directory specified by <code>path</code>, asynchronously.
   * <p>
   * The parameter <code>filter</code> is a regular expression. If <code>filter</code> is specified then only the paths that
   * match  @{filter}will be returned.
   * <p>
   * The result is an array of String representing the paths of the files inside the directory.
   */
  readDir(path: string, filter: string, handler: ((res: AsyncResult<string[]>) => void) | Handler<AsyncResult<string[]>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#readDir}
   */
  readDirBlocking(path: string, filter: string) : string[];

  /**
   * Reads the entire file as represented by the path <code>path</code> as a , asynchronously.
   * <p>
   * Do not use this method to read very large files or you risk running out of available RAM.
   */
  readFile(path: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#readFile}
   */
  readFileBlocking(path: string) : Buffer;

  /**
   * Creates the file, and writes the specified <code>Buffer data</code> to the file represented by the path <code>path</code>,
   * asynchronously.
   */
  writeFile(path: string, data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#writeFile}
   */
  writeFileBlocking(path: string, data: Buffer) : FileSystem;

  /**
   * Open the file represented by <code>path</code>, asynchronously.
   * <p>
   * The file is opened for both reading and writing. If the file does not already exist it will be created.
   */
  open(path: string, options: OpenOptions, handler: ((res: AsyncResult<AsyncFile>) => void) | Handler<AsyncResult<AsyncFile>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#open}
   */
  openBlocking(path: string, options: OpenOptions) : AsyncFile;

  /**
   * Creates an empty file with the specified <code>path</code>, asynchronously.
   */
  createFile(path: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createFile}
   */
  createFileBlocking(path: string) : FileSystem;

  /**
   * Creates an empty file with the specified <code>path</code> and permissions <code>perms</code>, asynchronously.
   */
  createFile(path: string, perms: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createFile}
   */
  createFileBlocking(path: string, perms: string) : FileSystem;

  /**
   * Determines whether the file as specified by the path <code>path</code> exists, asynchronously.
   */
  exists(path: string, handler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#exists}
   */
  existsBlocking(path: string) : boolean;

  /**
   * Returns properties of the file-system being used by the specified <code>path</code>, asynchronously.
   */
  fsProps(path: string, handler: ((res: AsyncResult<FileSystemProps>) => void) | Handler<AsyncResult<FileSystemProps>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#fsProps}
   */
  fsPropsBlocking(path: string) : FileSystemProps;

  /**
   * Creates a new directory in the default temporary-file directory, using the given
   * prefix to generate its name, asynchronously.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempDirectory(prefix: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempDirectory}
   */
  createTempDirectoryBlocking(prefix: string) : string;

  /**
   * Creates a new directory in the default temporary-file directory, using the given
   * prefix to generate its name, asynchronously.
   * <p>
   * The new directory will be created with permissions as specified by <code>perms</code>.
   * </p>
   * The permission String takes the form rwxr-x--- as specified
   * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempDirectory(prefix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempDirectory}
   */
  createTempDirectoryBlocking(prefix: string, perms: string) : string;

  /**
   * Creates a new directory in the directory provided by the path <code>path</code>, using the given
   * prefix to generate its name, asynchronously.
   * <p>
   * The new directory will be created with permissions as specified by <code>perms</code>.
   * </p>
   * The permission String takes the form rwxr-x--- as specified
   * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempDirectory(dir: string, prefix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempDirectory}
   */
  createTempDirectoryBlocking(dir: string, prefix: string, perms: string) : string;

  /**
   * Creates a new file in the default temporary-file directory, using the given
   * prefix and suffix to generate its name, asynchronously.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempFile(prefix: string, suffix: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempFile}
   */
  createTempFileBlocking(prefix: string, suffix: string) : string;

  /**
   * Creates a new file in the directory provided by the path <code>dir</code>, using the given
   * prefix and suffix to generate its name, asynchronously.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempFile(prefix: string, suffix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempFile}
   */
  createTempFileBlocking(prefix: string, suffix: string, perms: string) : string;

  /**
   * Creates a new file in the directory provided by the path <code>dir</code>, using the given
   * prefix and suffix to generate its name, asynchronously.
   * <p>
   * The new directory will be created with permissions as specified by <code>perms</code>.
   * </p>
   * The permission String takes the form rwxr-x--- as specified
   * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *
   * <p>
   * As with the <code>File.createTempFile</code> methods, this method is only
   * part of a temporary-file facility.A #addShutdownHook shutdown-hook,
   * or the deleteOnExit mechanism may be used to delete the directory automatically.
   * </p>
   */
  createTempFile(dir: string, prefix: string, suffix: string, perms: string, handler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : FileSystem;

  /**
   * Blocking version of {@link FileSystem#createTempFile}
   */
  createTempFileBlocking(dir: string, prefix: string, suffix: string, perms: string) : string;
}

/**
 * Represents properties of the file system.
 */
export abstract class FileSystemProps {
  /**
   */
  totalSpace() : number;

  /**
   */
  unallocatedSpace() : number;

  /**
   */
  usableSpace() : number;
}

/**
 * Represents the result of an action that may, or may not, have occurred yet.
 * <p>
 */
export abstract class Future<T> implements PromiseLike<T> {
  /**
   * Create a future that hasn't completed yet and that is passed to the <code>handler</code> before it is returned.
   */
  static future<T>(handler: ((res: Promise<T>) => void) | Handler<Promise<T>>) : Future<T>;

  /**
   * Create a future that hasn't completed yet
   */
  static future<T>() : Future<T>;

  /**
   * Create a succeeded future with a null result
   */
  static succeededFuture<T>() : Future<T>;

  /**
   * Created a succeeded future with the specified result.
   */
  static succeededFuture<T>(result: T) : Future<T>;

  /**
   * Create a failed future with the specified failure cause.
   */
  static failedFuture<T>(t: Throwable | Error) : Future<T>;

  /**
   * Create a failed future with the specified failure message.
   */
  static failedFuture<T>(failureMessage: string) : Future<T>;

  /**
   * Has the future completed?
   * <p>
   * It's completed if it's either succeeded or failed.
   */
  isComplete() : boolean;

  /**
   * Like {@link Future#onComplete}.
   */
  setHandler(handler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : Future<T>;

  /**
   * Add a handler to be notified of the result.
   * <br/>
   */
  onComplete(handler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : Future<T>;

  /**
   * Add a handler to be notified of the succeeded result.
   * <br/>
   */
  onSuccess(handler: ((res: T) => void) | Handler<T>) : Future<T>;

  /**
   * Add a handler to be notified of the failed result.
   * <br/>
   */
  onFailure(handler: ((res: Throwable) => void) | Handler<Throwable>) : Future<T>;

  /**
   * Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  complete(result: T) : void;

  /**
   * Set a null result. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  complete() : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  fail(cause: Throwable | Error) : void;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   */
  fail(failureMessage: string) : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryComplete(result: T) : boolean;

  /**
   * Try to set the result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryComplete() : boolean;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryFail(cause: Throwable | Error) : boolean;

  /**
   * Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   */
  tryFail(failureMessage: string) : boolean;

  /**
   * The result of the operation. This will be null if the operation failed.
   */
  result() : T;

  /**
   * A Throwable describing failure. This will be null if the operation succeeded.
   */
  cause() : Throwable;

  /**
   * Did it succeed?
   */
  succeeded() : boolean;

  /**
   * Did it fail?
   */
  failed() : boolean;

  /**
   * Alias for {@link Future#compose}.
   */
  flatMap<U>(mapper: (arg: T) => Future<U>) : Future<U>;

  /**
   * Compose this future with a <code>mapper</code> function.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) succeeds, the <code>mapper</code> will be called with
   * the completed value and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  compose<U>(mapper: (arg: T) => Future<U>) : Future<U>;

  /**
   * Compose this future with a <code>successMapper</code> and <code>failureMapper</code> functions.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) succeeds, the <code>successMapper</code> will be called with
   * the completed value and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * When this future (the one on which <code>compose</code> is called) fails, the <code>failureMapper</code> will be called with
   * the failure and this mapper returns another future object. This returned future completion will complete
   * the future returned by this method call.<p>
   * <p>
   * If any mapper function throws an exception, the returned future will be failed with this exception.<p>
   */
  compose<U>(successMapper: (arg: T) => Future<U>, failureMapper: (arg: Throwable) => Future<U>) : Future<U>;

  /**
   * Apply a <code>mapper</code> function on this future.<p>
   * <p>
   * When this future succeeds, the <code>mapper</code> will be called with the completed value and this mapper
   * returns a value. This value will complete the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  map<U>(mapper: (arg: T) => U) : Future<U>;

  /**
   * Map the result of a future to a specific <code>value</code>.<p>
   * <p>
   * When this future succeeds, this <code>value</code> will complete the future returned by this method call.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future.
   */
  map<V>(value: V) : Future<V>;

  /**
   * Map the result of a future to <code>null</code>.<p>
   * <p>
   * This is a conveniency for <code>future.map((T) null)</code> or <code>future.map((Void) null)</code>.<p>
   * <p>
   * When this future succeeds, <code>null</code> will complete the future returned by this method call.<p>
   * <p>
   * When this future fails, the failure will be propagated to the returned future.
   */
  mapEmpty<V>() : Future<V>;

  /**
   */
  completer() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Handles a failure of this Future by returning the result of another Future.
   * If the mapper fails, then the returned future will be failed with this failure.
   */
  recover(mapper: (arg: Throwable) => Future<T>) : Future<T>;

  /**
   * Apply a <code>mapper</code> function on this future.<p>
   * <p>
   * When this future fails, the <code>mapper</code> will be called with the completed value and this mapper
   * returns a value. This value will complete the future returned by this method call.<p>
   * <p>
   * If the <code>mapper</code> throws an exception, the returned future will be failed with this exception.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future and the <code>mapper</code>
   * will not be called.
   */
  otherwise(mapper: (arg: Throwable) => T) : Future<T>;

  /**
   * Map the failure of a future to a specific <code>value</code>.<p>
   * <p>
   * When this future fails, this <code>value</code> will complete the future returned by this method call.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future.
   */
  otherwise(value: T) : Future<T>;

  /**
   * Map the failure of a future to <code>null</code>.<p>
   * <p>
   * This is a convenience for <code>future.otherwise((T) null)</code>.<p>
   * <p>
   * When this future fails, the <code>null</code> value will complete the future returned by this method call.<p>
   * <p>
   * When this future succeeds, the result will be propagated to the returned future.
   */
  otherwiseEmpty() : Future<T>;

  /**
   * Attaches callbacks for the resolution and/or rejection of the Future.
   * @param onfulfilled The callback to execute when the Future is resolved.
   * @param onrejected The callback to execute when the Future is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
   then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;
}

import { WebSocketConnectOptions } from './options';
import { RequestOptions } from './options';
import { HttpMethod } from './enums';
import { WebsocketVersion } from './enums';

/**
 * An asynchronous HTTP client.
 * <p>
 * It allows you to make requests to HTTP servers, and a single client can make requests to any server.
 * <p>
 * It also allows you to open WebSockets to servers.
 * <p>
 * The client can also pool HTTP connections.
 * <p>
 * For pooling to occur, keep-alive must be true on the <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a> (default is true).
 * In this case connections will be pooled and re-used if there are pending HTTP requests waiting to get a connection,
 * otherwise they will be closed.
 * <p>
 * This gives the benefits of keep alive when the client is loaded but means we don't keep connections hanging around
 * unnecessarily when there would be no benefits anyway.
 * <p>
 * The client also supports pipe-lining of requests. Pipe-lining means another request is sent on the same connection
 * before the response from the preceding one has returned. Pipe-lining is not appropriate for all requests.
 * <p>
 * To enable pipe-lining, it must be enabled on the <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a> (default is false).
 * <p>
 * When pipe-lining is enabled the connection will be automatically closed when all in-flight responses have returned
 * and there are no outstanding pending requests to write.
 * <p>
 * The client is designed to be reused between requests.
 */
export abstract class HttpClient implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Like {@link HttpClient#request} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>options</code> parameter.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  request(method: HttpMethod, serverAddress: SocketAddress, options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server with the specified options.
   */
  request(method: HttpMethod, options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and port.
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Like {@link HttpClient#request} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>host</code> and <code>port</code> parameters.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  request(method: HttpMethod, serverAddress: SocketAddress, port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and default port.
   */
  request(method: HttpMethod, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server with the specified options, specifying a response handler to receive
   */
  request(method: HttpMethod, options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link HttpClient#request} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>options</code> parameter.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  request(method: HttpMethod, serverAddress: SocketAddress, options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link HttpClient#request} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>host</code> and <code>port</code> parameters.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  request(method: HttpMethod, serverAddress: SocketAddress, port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  request(method: HttpMethod, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the default host and port.
   */
  request(method: HttpMethod, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  request(method: HttpMethod, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server using an absolute URI
   */
  requestAbs(method: HttpMethod, absoluteURI: string) : HttpClientRequest;

  /**
   * Like {@link HttpClient#requestAbs} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>absoluteURI</code> parameter.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  requestAbs(method: HttpMethod, serverAddress: SocketAddress, absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  requestAbs(method: HttpMethod, absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Like {@link HttpClient#requestAbs} using the <code>serverAddress</code> parameter to connect to the
   * server instead of the <code>absoluteURI</code> parameter.
   * <p>
   * The request host header will still be created from the <code>absoluteURI</code> parameter.
   * <p>
   * Use  to connect to a unix domain socket server.
   */
  requestAbs(method: HttpMethod, serverAddress: SocketAddress, absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server with the specified options.
   */
  get(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and port.
   */
  get(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and default port.
   */
  get(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  get(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  get(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  get(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the default host and port.
   */
  get(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  get(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server using an absolute URI
   */
  getAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP GET request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  getAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP GET request to the server with the specified options, specifying a response handler to receive
   * the response
   */
  getNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  getNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  getNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP GET request  to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  getNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP POST request to send to the server with the specified options.
   */
  post(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and port.
   */
  post(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and default port.
   */
  post(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  post(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  post(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  post(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the default host and port.
   */
  post(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  post(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server using an absolute URI
   */
  postAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP POST request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  postAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server with the specified options.
   */
  head(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and port.
   */
  head(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and default port.
   */
  head(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  head(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  head(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  head(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the default host and port.
   */
  head(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  head(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server using an absolute URI
   */
  headAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP HEAD request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  headAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP HEAD request to the server with the specified options, specifying a response handler to receive
   * the response
   */
  headNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  headNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  headNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP HEAD request  to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  headNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP OPTIONS request to send to the server with the specified options.
   */
  options(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and port.
   */
  options(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and default port.
   */
  options(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  options(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  options(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  options(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the default host and port.
   */
  options(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  options(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server using an absolute URI
   */
  optionsAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP OPTIONS request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  optionsAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Sends an HTTP OPTIONS request to the server with the specified options, specifying a response handler to receive
   * the response
   */
  optionsNow(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  optionsNow(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  optionsNow(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Sends an HTTP OPTIONS request  to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  optionsNow(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClient;

  /**
   * Create an HTTP PUT request to send to the server with the specified options.
   */
  put(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and port.
   */
  put(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and default port.
   */
  put(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  put(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  put(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  put(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the default host and port.
   */
  put(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  put(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server using an absolute URI
   */
  putAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP PUT request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  putAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server with the specified options.
   */
  delete(options: RequestOptions) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and port.
   */
  delete(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and default port.
   */
  delete(host: string, requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server with the specified options, specifying a response handler to receive
   * the response
   */
  delete(options: RequestOptions, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and port, specifying a response handler to receive
   * the response
   */
  delete(port: number, host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the specified host and default port, specifying a response handler to receive
   * the response
   */
  delete(host: string, requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the default host and port.
   */
  delete(requestURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server at the default host and port, specifying a response handler to receive
   * the response
   */
  delete(requestURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server using an absolute URI
   */
  deleteAbs(absoluteURI: string) : HttpClientRequest;

  /**
   * Create an HTTP DELETE request to send to the server using an absolute URI, specifying a response handler to receive
   * the response
   */
  deleteAbs(absoluteURI: string, responseHandler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse>) : HttpClientRequest;

  /**
   * Connect a WebSocket with the specified options
   */
  websocket(options: RequestOptions, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options
   */
  websocket(options: RequestOptions, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   */
  websocket(host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   */
  websocket(host: string, requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, and with the specified headers
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, and with the specified headers
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket with the specified optionsI, with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   * the specified version of WebSockets
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket with the specified absolute url, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols.
   */
  websocketAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket with the specified options, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   */
  websocket(requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   */
  websocket(requestURI: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   * specified version of WebSockets
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   * specified version of WebSockets
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   * specified version of WebSockets and the specified sub protocols
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>) : HttpClient;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   * specified version of WebSockets and the specified sub protocols
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: ((res: WebSocket) => void) | Handler<WebSocket>, failureHandler: ((res: Throwable) => void) | Handler<Throwable>) : HttpClient;

  /**
   * Connect a WebSocket to the specified port, host and relative request URI
   */
  webSocket(port: number, host: string, requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket to the host and relative request URI and default port
   */
  webSocket(host: string, requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket at the relative request URI using the default host and port
   */
  webSocket(requestURI: string, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket with the specified options.
   */
  webSocket(options: WebSocketConnectOptions, handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Connect a WebSocket with the specified absolute url, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols.
   */
  webSocketAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string[], handler: ((res: AsyncResult<WebSocket>) => void) | Handler<AsyncResult<WebSocket>>) : void;

  /**
   * Create a WebSocket stream with the specified options
   */
  websocketStream(options: RequestOptions) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI
   */
  websocketStream(port: number, host: string, requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port
   */
  websocketStream(host: string, requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options, and with the specified headers
   */
  websocketStream(options: RequestOptions, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, and with the specified headers
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port and with the specified headers
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options, with the specified headers and using
   * the specified version of WebSockets
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers and using
   * the specified version of WebSockets
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified options and with the specified headers and using
   * the specified version of WebSockets
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream with the specified absolute url, the specified headers, using the specified version of WebSockets,
   * and the specified WebSocket sub protocols.
   */
  websocketStreamAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream to the specified host, relative request URI and default port, with the specified headers, using
   * the specified version of WebSockets, and the specified WebSocket sub protocols
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   */
  websocketStream(requestURI: string) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   */
  websocketStream(requestURI: string, headers: MultiMap) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port, the specified headers and the
   * specified version of WebSockets
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream<WebSocket>;

  /**
   * Create a WebSocket stream at the relative request URI using the default host and port, the specified headers, the
   * specified version of WebSockets and the specified sub protocols
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream<WebSocket>;

  /**
   * Set a connection handler for the client. This handler is called when a new connection is established.
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection>) : HttpClient;

  /**
   * Set a redirect handler for the http client.
   * <p>
   * The redirect handler is called when a <code>3xx</code> response is received and the request is configured to
   * follow redirects with {@link HttpClientRequest#setFollowRedirects}.
   * <p>
   * The redirect handler is passed the {@link HttpClientResponse}, it can return an {@link HttpClientRequest} or <code>null</code>.
   * <ul>
   *   <li>when null is returned, the original response is processed by the original request response handler</li>
   *   <li>when a new <code>Future<HttpClientRequest></code> is returned, the client will send this new request</li>
   * </ul>
   * The new request will get a copy of the previous request headers unless headers are set. In this case,
   * the client assumes that the redirect handler exclusively managers the headers of the new request.
   * <p>
   * The handler must return a <code>Future<HttpClientRequest></code> unsent so the client can further configure it and send it.
   */
  redirectHandler(handler: (arg: HttpClientResponse) => Future<HttpClientRequest>) : HttpClient;

  /**
   * Close the client. Closing will close down any pooled connections.
   * Clients should always be closed after use.
   */
  close() : void;
}

import { StreamPriority } from './options';
import { HttpVersion } from './enums';

/**
 * Represents a client-side HTTP request.
 * <p>
 * Instances are created by an {@link HttpClient} instance, via one of the methods corresponding to the
 * specific HTTP methods, or the generic request methods. On creation the request will not have been written to the
 * wire.
 * <p>
 * Once a request has been obtained, headers can be set on it, and data can be written to its body if required. Once
 * you are ready to send the request, one of the {@link HttpClientRequest#end} methods should be called.
 * <p>
 * Nothing is actually sent until the request has been internally assigned an HTTP connection.
 * <p>
 * The {@link HttpClient} instance will return an instance of this class immediately, even if there are no HTTP
 * connections available in the pool. Any requests sent before a connection is assigned will be queued
 * internally and actually sent when an HTTP connection becomes available from the pool.
 * <p>
 * The headers of the request are queued for writing either when the {@link HttpClientRequest#end} method is called, or, when the first
 * part of the body is written, whichever occurs first.
 * <p>
 * This class supports both chunked and non-chunked HTTP.
 * <p>
 * It implements {@link WriteStream} so it can be used with
 * {@link Pump} to pump data with flow control.
 * <p>
 * An example of using this class is as follows:
 * <p>
 */
export abstract class HttpClientRequest implements ReadStream<HttpClientResponse>, WriteStream<Buffer> {
  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link HttpClientRequest#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<HttpClientResponse>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<HttpClientResponse>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<HttpClientResponse>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : HttpClientRequest;

  /**
   */
  write(data: Buffer) : HttpClientRequest;

  /**
   * Same as {@link HttpClientRequest#write} but with an <code>handler</code> called when the operation completes
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  setWriteQueueMaxSize(maxSize: number) : HttpClientRequest;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  /**
   */
  handler(handler: ((res: HttpClientResponse) => void) | Handler<HttpClientResponse> | null | undefined) : HttpClientRequest;

  /**
   */
  pause() : HttpClientRequest;

  /**
   */
  resume() : HttpClientRequest;

  /**
   */
  fetch(amount: number) : HttpClientRequest;

  /**
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  /**
   * Set the request to follow HTTP redirects up to <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>.
   */
  setFollowRedirects(followRedirects: boolean) : HttpClientRequest;

  /**
   * Set the max number of HTTP redirects this request will follow. The default is <code>0</code> which means
   * no redirects.
   */
  setMaxRedirects(maxRedirects: number) : HttpClientRequest;

  /**
   * If chunked is true then the request will be set into HTTP chunked mode
   */
  setChunked(chunked: boolean) : HttpClientRequest;

  /**
   */
  isChunked() : boolean;

  /**
   * The HTTP method for the request.
   */
  method() : HttpMethod;

  /**
   */
  getRawMethod() : string;

  /**
   * Set the value the method to send when the method  is used.
   */
  setRawMethod(method: string) : HttpClientRequest;

  /**
   */
  absoluteURI() : string;

  /**
   */
  uri() : string;

  /**
   */
  path() : string;

  /**
   */
  query() : string;

  /**
   * Set the request host.<p/>
   *
   * For HTTP/2 it sets the  pseudo header otherwise it sets the  header
   */
  setHost(host: string) : HttpClientRequest;

  /**
   */
  getHost() : string;

  /**
   */
  headers() : MultiMap;

  /**
   * Put an HTTP header
   */
  putHeader(name: string, value: string) : HttpClientRequest;

  /**
   * Write a String to the request body, encoded as UTF-8.
   */
  write(chunk: string) : HttpClientRequest;

  /**
   * Same as {@link HttpClientRequest#write} but with an <code>handler</code> called when the operation completes
   */
  write(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  /**
   * Write a String to the request body, encoded using the encoding <code>enc</code>.
   */
  write(chunk: string, enc: string) : HttpClientRequest;

  /**
   * Same as {@link HttpClientRequest#write} but with an <code>handler</code> called when the operation completes
   */
  write(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpClientRequest;

  /**
   * If you send an HTTP request with the header <code>Expect</code> set to the value <code>100-continue</code>
   * and the server responds with an interim HTTP response with a status code of <code>100</code> and a continue handler
   * has been set using this method, then the <code>handler</code> will be called.
   * <p>
   * You can then continue to write data to the request body and later end it. This is normally used in conjunction with
   * the {@link HttpClientRequest#sendHead} method to force the request header to be written before the request has ended.
   */
  continueHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientRequest;

  /**
   * Forces the head of the request to be written before {@link HttpClientRequest#end} is called on the request or any data is
   * written to it.
   * <p>
   * This is normally used to implement HTTP 100-continue handling, see  for
   * more information.
   */
  sendHead() : HttpClientRequest;

  /**
   * Like {@link HttpClientRequest#sendHead} but with an handler after headers have been sent. The handler will be called with
   * the <a href="../../enums.html#HttpVersion">HttpVersion</a> if it can be determined or null otherwise.<p>
   */
  sendHead(completionHandler: ((res: HttpVersion) => void) | Handler<HttpVersion>) : HttpClientRequest;

  /**
   * Same as {@link HttpClientRequest#end} but writes a String in UTF-8 encoding
   */
  end(chunk: string) : void;

  /**
   * Same as {@link HttpClientRequest#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link HttpClientRequest#end} but writes a String with the specified encoding
   */
  end(chunk: string, enc: string) : void;

  /**
   * Same as {@link HttpClientRequest#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link HttpClientRequest#end} but writes some data to the request body before ending. If the request is not chunked and
   * no other data has been written then the <code>Content-Length</code> header will be automatically set
   */
  end(chunk: Buffer) : void;

  /**
   * Same as {@link HttpClientRequest#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Ends the request. If no data has been written to the request body, and {@link HttpClientRequest#sendHead} has not been called then
   * the actual request won't get written until this method gets called.
   * <p>
   * Once the request has ended, it cannot be used any more,
   */
  end() : void;

  /**
   * Same as {@link HttpClientRequest#end} but with an <code>handler</code> called when the operation completes
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set's the amount of time after which if the request does not return any data within the timeout period an
   * TimeoutException will be passed to the exception handler (if provided) and
   * the request will be closed.
   * <p>
   * Calling this method more than once has the effect of canceling any existing timeout and starting
   * the timeout from scratch.
   */
  setTimeout(timeoutMs: number) : HttpClientRequest;

  /**
   * Set a push handler for this request.<p/>
   *
   * The handler is called when the client receives a <i>push promise</i> from the server. The handler can be called
   * multiple times, for each push promise.<p/>
   *
   * The handler is called with a <i>read-only</i> {@link HttpClientRequest}, the following methods can be called:<p/>
   *
   * <ul>
   *   <li>{@link HttpClientRequest#method}</li>
   *   <li>{@link HttpClientRequest#uri}</li>
   *   <li>{@link HttpClientRequest#headers}</li>
   *   <li>{@link HttpClientRequest#getHost}</li>
   * </ul>
   *
   * In addition the handler should call the {@link HttpClientRequest#handler} method to set an handler to
   * process the response.<p/>
   */
  pushHandler(handler: ((res: HttpClientRequest) => void) | Handler<HttpClientRequest>) : HttpClientRequest;

  /**
   * Reset this stream with the error code <code>0</code>.
   */
  reset() : boolean;

  /**
   * Reset this request:
   * <p/>
   * <ul>
   *   <li>for HTTP/2, this performs send an HTTP/2 reset frame with the specified error <code>code</code></li>
   *   <li>for HTTP/1.x, this closes the connection when the current request is inflight</li>
   * </ul>
   * <p/>
   * When the request has not yet been sent, the request will be aborted and false is returned as indicator.
   * <p/>
   */
  reset(code: number) : boolean;

  /**
   */
  connection() : HttpConnection;

  /**
   * Set a connection handler called when an HTTP connection has been established.
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection> | null | undefined) : HttpClientRequest;

  /**
   * Write an HTTP/2 frame to the request, allowing to extend the HTTP/2 protocol.<p>
   *
   * The frame is sent immediatly and is not subject to flow control.<p>
   *
   * This method must be called after the request headers have been sent and only for the protocol HTTP/2.
   * The {@link HttpClientRequest#sendHead} should be used for this purpose.
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpClientRequest;

  /**
   */
  streamId() : number;

  /**
   * Like {@link HttpClientRequest#writeCustomFrame} but with an {@link HttpFrame}.
   */
  writeCustomFrame(frame: HttpFrame) : HttpClientRequest;

  /**
   * Sets the priority of the associated stream.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  setStreamPriority(streamPriority: StreamPriority) : HttpClientRequest;

  /**
   */
  getStreamPriority() : StreamPriority;

  /**
   * Like {@link HttpClientRequest#putHeader} but using CharSequence
   */
  putHeader(name: string, value: string) : HttpClientRequest;

  /**
   * Put an HTTP header with multiple values
   */
  putHeader(name: string, values: any /* java.lang.Iterable<java.lang.String> */) : HttpClientRequest;

  /**
   * Like {@link HttpClientRequest#putHeader} but using CharSequence
   */
  putHeader(name: string, values: any /* java.lang.Iterable<java.lang.CharSequence> */) : HttpClientRequest;
}

/**
 * Represents a client-side HTTP response.
 * <p>
 * Vert.x provides you with one of these via the handler that was provided when creating the {@link HttpClientRequest}
 * or that was set on the {@link HttpClientRequest} instance.
 * <p>
 * It implements {@link ReadStream} so it can be used with
 * {@link Pump} to pump data with flow control.
 */
export abstract class HttpClientResponse implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  fetch(amount: number) : HttpClientResponse;

  resume() : HttpClientResponse;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : HttpClientResponse;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpClientResponse;

  pause() : HttpClientResponse;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpClientResponse;

  /**
   */
  version() : HttpVersion;

  /**
   */
  statusCode() : number;

  /**
   */
  statusMessage() : string;

  /**
   */
  headers() : MultiMap;

  /**
   * Return the first header value with the specified name
   */
  getHeader(headerName: string) : string | null;

  /**
   * Return the first trailer value with the specified name
   */
  getTrailer(trailerName: string) : string | null;

  /**
   */
  trailers() : MultiMap;

  /**
   */
  cookies() : string[];

  /**
   * Convenience method for receiving the entire request body in one piece.
   * <p>
   * This saves you having to manually set a dataHandler and an endHandler and append the chunks of the body until
   * the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   */
  bodyHandler(bodyHandler: ((res: Buffer) => void) | Handler<Buffer>) : HttpClientResponse;

  /**
   * Set an custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   * frame. HTTP/2 permits extension of the protocol.
   */
  customFrameHandler(handler: ((res: HttpFrame) => void) | Handler<HttpFrame>) : HttpClientResponse;

  /**
   * Get a net socket for the underlying connection of this request.
   * <p>
   * USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol.
   * <p>
   * HTTP/1.1 pipe-lined requests cannot support net socket upgrade.
   * <p>
   * One valid use-case for calling this is to receive the {@link NetSocket} after a HTTP CONNECT was issued to the
   * remote peer and it responded with a status code of 200.
   */
  netSocket() : NetSocket;

  /**
   */
  request() : HttpClientRequest;

  /**
   * Set an handler for stream priority changes.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  streamPriorityHandler(handler: ((res: StreamPriority) => void) | Handler<StreamPriority>) : HttpClientResponse;

  /**
   * Return the first header value with the specified name
   */
  getHeader(headerName: string) : string;
}

import { GoAway } from './options';
import { Http2Settings } from './options';

/**
 * Represents an HTTP connection.
 * <p/>
 * HTTP/1.x connection provides an limited implementation, the following methods are implemented:
 * <ul>
 *   <li>{@link HttpConnection#close}</li>
 *   <li>{@link HttpConnection#closeHandler}</li>
 *   <li>{@link HttpConnection#exceptionHandler}</li>
 * </ul>
 */
export abstract class HttpConnection {
  /**
   */
  getWindowSize() : number;

  /**
   * Update the current connection wide window size to a new size.
   * <p/>
   * Increasing this value, gives better performance when several data streams are multiplexed
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  setWindowSize(windowSize: number) : HttpConnection;

  /**
   * Like {@link HttpConnection#goAway} with a last stream id <code>-1</code> which means to disallow any new stream creation.
   */
  goAway(errorCode: number) : HttpConnection;

  /**
   * Like {@link HttpConnection#goAway} with no buffer.
   */
  goAway(errorCode: number, lastStreamId: number) : HttpConnection;

  /**
   * Send a go away frame to the remote endpoint of the connection.
   * <p/>
   * <ul>
   *   <li>a  frame is sent to the to the remote endpoint with the <code>errorCode</code> and <code>debugData</code></li>
   *   <li>any stream created after the stream identified by <code>lastStreamId</code> will be closed</li>
   *   <li>for an  is different than <code>0</code> when all the remaining streams are closed this connection will be closed automatically</li>
   * </ul>
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  goAway(errorCode: number, lastStreamId: number, debugData: Buffer) : HttpConnection;

  /**
   * Set an handler called when a  frame is received.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  goAwayHandler(handler: ((res: GoAway) => void) | Handler<GoAway> | null | undefined) : HttpConnection;

  /**
   * Set an handler called when a  frame has been sent or received and all connections are closed.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  shutdownHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpConnection;

  /**
   * Initiate a graceful connection shutdown, the connection is taken out of service and closed when all current requests
   * are processed, otherwise after 30 seconds the connection will be closed. Client connection are immediately removed
   * from the pool.
   *
   * <ul>
   *   <li>HTTP/2 connections will send a go away frame immediately to signal the other side the connection will close</li>
   *   <li>HTTP/1.x client connection supports this feature</li>
   *   <li>HTTP/1.x server connections do not support this feature</li>
   * </ul>
   */
  shutdown() : HttpConnection;

  /**
   * Like {@link HttpConnection#shutdown} but with a configurable timeout value.
   */
  shutdown(timeoutMs: number) : HttpConnection;

  /**
   * Set a close handler. The handler will get notified when the connection is closed.
   */
  closeHandler(handler: ((res: void) => void) | Handler<void>) : HttpConnection;

  /**
   * Close the connection and all the currently active streams.
   * <p/>
   * An HTTP/2 connection will send a  frame before.
   */
  close() : void;

  /**
   */
  settings() : Http2Settings;

  /**
   * Send to the remote endpoint an update of the server settings.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  updateSettings(settings: Http2Settings) : HttpConnection;

  /**
   * Send to the remote endpoint an update of this endpoint settings
   * <p/>
   * The <code>completionHandler</code> will be notified when the remote endpoint has acknowledged the settings.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  updateSettings(settings: Http2Settings, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpConnection;

  /**
   */
  remoteSettings() : Http2Settings;

  /**
   * Set an handler that is called when remote endpoint <a href="../../dataobjects.html#Http2Settings">Http2Settings</a> are updated.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  remoteSettingsHandler(handler: ((res: Http2Settings) => void) | Handler<Http2Settings>) : HttpConnection;

  /**
   * Send a  frame to the remote endpoint.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  ping(data: Buffer, pongHandler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : HttpConnection;

  /**
   * Set an handler notified when a  frame is received from the remote endpoint.
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  pingHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpConnection;

  /**
   * Set an handler called when a connection error happens
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable>) : HttpConnection;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   */
  isSsl() : boolean;

  /**
   * Returns the SNI server name presented during the SSL handshake by the client.
   */
  indicatedServerName() : string;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * An HTTP/2 frame.
 */
export abstract class HttpFrame {
  /**
   */
  type() : number;

  /**
   */
  flags() : number;

  /**
   */
  payload() : Buffer;
}

/**
 * An HTTP and WebSockets server.
 * <p>
 * You receive HTTP requests by providing a {@link HttpServer#requestHandler}. As requests arrive on the server the handler
 * will be called with the requests.
 * <p>
 * You receive WebSockets by providing a {@link HttpServer#webSocketHandler}. As WebSocket connections arrive on the server, the
 * WebSocket is passed to the handler.
 */
export abstract class HttpServer implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Return the request stream for the server. As HTTP requests are received by the server,
   * instances of {@link HttpServerRequest} will be created and passed to the stream .
   */
  requestStream() : ReadStream<HttpServerRequest>;

  /**
   * Set the request handler for the server to <code>requestHandler</code>. As HTTP requests are received by the server,
   * instances of {@link HttpServerRequest} will be created and passed to this handler.
   */
  requestHandler(handler: ((res: HttpServerRequest) => void) | Handler<HttpServerRequest>) : HttpServer;

  /**
   * Set a connection handler for the server.
   */
  connectionHandler(handler: ((res: HttpConnection) => void) | Handler<HttpConnection>) : HttpServer;

  /**
   * Set an exception handler called for socket errors happening before the HTTP connection
   * is established, e.g during the TLS handshake.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable>) : HttpServer;

  /**
   * Return the WebSocket stream for the server. If a webSocket connect handshake is successful a
   * new {@link ServerWebSocket} instance will be created and passed to the stream .
   */
  websocketStream() : ReadStream<ServerWebSocket>;

  /**
   * Return the WebSocket stream for the server. If a WebSocket connect handshake is successful a
   * new {@link ServerWebSocket} instance will be created and passed to the stream .
   */
  webSocketStream() : ReadStream<ServerWebSocket>;

  /**
   * Set the WebSocket handler for the server to <code>wsHandler</code>. If a WebSocket connect handshake is successful a
   * new {@link ServerWebSocket} instance will be created and passed to the handler.
   */
  websocketHandler(handler: ((res: ServerWebSocket) => void) | Handler<ServerWebSocket>) : HttpServer;

  /**
   * Set the WebSocket handler for the server to <code>wsHandler</code>. If a WebSocket connect handshake is successful a
   * new {@link ServerWebSocket} instance will be created and passed to the handler.
   */
  webSocketHandler(handler: ((res: ServerWebSocket) => void) | Handler<ServerWebSocket>) : HttpServer;

  /**
   * Tell the server to start listening. The server will listen on the port and host specified in the
   * <a href="../../dataobjects.html#HttpServerOptions">HttpServerOptions</a> that was used when creating the server.
   * <p>
   * The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   */
  listen() : HttpServer;

  /**
   * Tell the server to start listening. The server will listen on the port and host specified here,
   * ignoring any value set in the <a href="../../dataobjects.html#HttpServerOptions">HttpServerOptions</a> that was used when creating the server.
   * <p>
   * The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   */
  listen(port: number, host: string) : HttpServer;

  /**
   * Like {@link HttpServer#listen} but supplying a handler that will be called when the server is actually
   * listening (or has failed).
   */
  listen(port: number, host: string, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Tell the server to start listening on the given address supplying
   * a handler that will be called when the server is actually
   * listening (or has failed).
   */
  listen(address: SocketAddress, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Like {@link HttpServer#listen} but the server will listen on host "0.0.0.0" and port specified here ignoring
   * any value in the <a href="../../dataobjects.html#HttpServerOptions">HttpServerOptions</a> that was used when creating the server.
   */
  listen(port: number) : HttpServer;

  /**
   * Like {@link HttpServer#listen} but supplying a handler that will be called when the server is actually listening (or has failed).
   */
  listen(port: number, listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Like {@link HttpServer#listen} but supplying a handler that will be called when the server is actually listening (or has failed).
   */
  listen(listenHandler: ((res: AsyncResult<HttpServer>) => void) | Handler<AsyncResult<HttpServer>>) : HttpServer;

  /**
   * Close the server. Any open HTTP connections will be closed.
   * <p>
   * The close happens asynchronously and the server may not be closed until some time after the call has returned.
   */
  close() : void;

  /**
   * Like {@link HttpServer#close} but supplying a handler that will be called when the server is actually closed (or has failed).
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   * signifying an ephemeral port
   */
  actualPort() : number;
}

/**
 * Represents an file upload from an HTML FORM.
 */
export abstract class HttpServerFileUpload implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : HttpServerFileUpload;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerFileUpload;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerFileUpload;

  pause() : HttpServerFileUpload;

  resume() : HttpServerFileUpload;

  fetch(amount: number) : HttpServerFileUpload;

  /**
   * Stream the content of this upload to the given file on storage.
   */
  streamToFileSystem(filename: string) : HttpServerFileUpload;

  /**
   */
  filename() : string;

  /**
   */
  name() : string;

  /**
   */
  contentType() : string;

  /**
   */
  contentTransferEncoding() : string;

  /**
   */
  charset() : string;

  /**
   * The size of the upload may not be available until it is all read.
   * Check {@link HttpServerFileUpload#isSizeAvailable} to determine this
   */
  size() : number;

  /**
   */
  isSizeAvailable() : boolean;

  /**
   */
  file() : AsyncFile;
}

/**
 * Represents a server-side HTTP request.
 * <p>
 * Instances are created for each request and passed to the user via a handler.
 * <p>
 * Each instance of this class is associated with a corresponding {@link HttpServerResponse} instance via
 * {@link HttpServerRequest#response}.<p>
 * It implements {@link ReadStream} so it can be used with
 * {@link Pump} to pump data with flow control.
 * <p>
 */
export abstract class HttpServerRequest implements ReadStream<Buffer> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : HttpServerRequest;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerRequest;

  pause() : HttpServerRequest;

  resume() : HttpServerRequest;

  fetch(amount: number) : HttpServerRequest;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerRequest;

  /**
   */
  version() : HttpVersion;

  /**
   */
  method() : HttpMethod;

  /**
   */
  rawMethod() : string;

  /**
   */
  isSSL() : boolean;

  /**
   */
  scheme() : string | null;

  /**
   */
  uri() : string;

  /**
   */
  path() : string | null;

  /**
   */
  query() : string | null;

  /**
   */
  host() : string | null;

  /**
   */
  bytesRead() : number;

  /**
   */
  response() : HttpServerResponse;

  /**
   */
  headers() : MultiMap;

  /**
   * Return the first header value with the specified name
   */
  getHeader(headerName: string) : string | null;

  /**
   */
  params() : MultiMap;

  /**
   * Return the first param value with the specified name
   */
  getParam(paramName: string) : string | null;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   */
  absoluteURI() : string;

  /**
   * Convenience method for receiving the entire request body in one piece.
   * <p>
   * This saves the user having to manually setting a data and end handler and append the chunks of the body until
   * the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   */
  bodyHandler(bodyHandler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : HttpServerRequest;

  /**
   * Get a net socket for the underlying connection of this request.
   * <p/>
   * This method must be called before the server response is ended.
   * <p/>
   * With <code>CONNECT</code> requests, a <code>200</code> response is sent with no <code>content-length</code> header set
   * before returning the socket.
   * <p/>
   * <pre>
   * server.requestHandler(req -> {
   *   if (req.method() == HttpMethod.CONNECT) {
   *     // Send a 200 response to accept the connect
   *     NetSocket socket = req.netSocket();
   *     socket.handler(buff -> {
   *       socket.write(buff);
   *     });
   *   }
   *   ...
   * });
   * </pre>
   * <p/>
   * For other HTTP/1 requests once you have called this method, you must handle writing to the connection yourself using
   * the net socket, the server request instance will no longer be usable as normal. USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're
   * doing can easily break the HTTP protocol.
   * <p/>
   * With HTTP/2, a <code>200</code> response is always sent with no <code>content-length</code> header set before returning the socket
   * like in the <code>CONNECT</code> case above.
   * <p/>
   */
  netSocket() : NetSocket;

  /**
   * Establish a TCP <a href="https://tools.ietf.org/html/rfc7231#section-4.3.6">tunnel<a/> with the client.
   *
   * <p> This must be called only for <code>CONNECT</code> HTTP method and before any response is sent.
   *
   * <p> Calling this sends a <code>200</code> response with no <code>content-length</code> header set and
   * then provides the <code>NetSocket</code> for handling the created tunnel. Any HTTP header set on the
   * response before calling this method will be sent.
   *
   * <pre>
   * server.requestHandler(req -> {
   *   if (req.method() == HttpMethod.CONNECT) {
   *     // Send a 200 response to accept the connect
   *     NetSocket socket = req.netSocket();
   *     socket.handler(buff -> {
   *       socket.write(buff);
   *     });
   *   }
   *   ...
   * });
   * </pre>
   */
  toNetSocket(handler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : void;

  /**
   * Call this with true if you are expecting a multi-part body to be submitted in the request.
   * This must be called before the body of the request has been received
   */
  setExpectMultipart(expect: boolean) : HttpServerRequest;

  /**
   */
  isExpectMultipart() : boolean;

  /**
   * Set an upload handler. The handler will get notified once a new file upload was received to allow you to deal
   * with the file upload.
   */
  uploadHandler(uploadHandler: ((res: HttpServerFileUpload) => void) | Handler<HttpServerFileUpload> | null | undefined) : HttpServerRequest;

  /**
   * Returns a map of all form attributes in the request.
   * <p>
   * Be aware that the attributes will only be available after the whole body has been received, i.e. after
   * the request end handler has been called.
   * <p>
   * {@link HttpServerRequest#setExpectMultipart} must be called first before trying to get the form attributes.
   */
  formAttributes() : MultiMap;

  /**
   * Return the first form attribute value with the specified name
   */
  getFormAttribute(attributeName: string) : string | null;

  /**
   * Upgrade the connection to a WebSocket connection.
   * <p>
   * This is an alternative way of handling WebSockets and can only be used if no WebSocket handler is set on the
   * <code>HttpServer</code>, and can only be used during the upgrade request during the WebSocket handshake.
   */
  upgrade() : ServerWebSocket;

  /**
   * Upgrade the connection of the current request to a WebSocket.
   * <p>
   * This is an alternative way of handling WebSockets and can only be used if no WebSocket handler is set on the
   * <code>HttpServer</code>, and can only be used during the upgrade request during the WebSocket handshake.
   *
   * <p> Both {@link HttpServerRequest#handler} and {@link HttpServerRequest#endHandler} will be set to get the full body of the
   * request that is necessary to perform the WebSocket handshake.
   *
   * <p> If you need to do an asynchronous upgrade, i.e not performed immediately in your request handler,
   * you need to {@link HttpServerRequest#pause} the request in order to not lose HTTP events necessary to upgrade the
   * request.
   */
  toWebSocket(handler: ((res: AsyncResult<ServerWebSocket>) => void) | Handler<AsyncResult<ServerWebSocket>>) : void;

  /**
   * Has the request ended? I.e. has the entire request, including the body been read?
   */
  isEnded() : boolean;

  /**
   * Set a custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   * frame. HTTP/2 permits extension of the protocol.
   */
  customFrameHandler(handler: ((res: HttpFrame) => void) | Handler<HttpFrame>) : HttpServerRequest;

  /**
   */
  connection() : HttpConnection;

  /**
   */
  streamPriority() : StreamPriority;

  /**
   * Set an handler for stream priority changes
   * <p>
   * This is not implemented for HTTP/1.x.
   */
  streamPriorityHandler(handler: ((res: StreamPriority) => void) | Handler<StreamPriority>) : HttpServerRequest;

  /**
   * Get the cookie with the specified name.
   */
  getCookie(name: string) : Cookie | null;

  /**
   */
  cookieCount() : number;

  /**
   * Return the first header value with the specified name
   */
  getHeader(headerName: string) : string;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * Represents a server-side HTTP response.
 * <p>
 * An instance of this is created and associated to every instance of
 * {@link HttpServerRequest} that.
 * <p>
 * It allows the developer to control the HTTP response that is sent back to the
 * client for a particular HTTP request.
 * <p>
 * It contains methods that allow HTTP headers and trailers to be set, and for a body to be written out to the response.
 * <p>
 * It also allows files to be streamed by the kernel directly from disk to the
 * outgoing HTTP connection, bypassing user space altogether (where supported by
 * the underlying operating system). This is a very efficient way of
 * serving files from the server since buffers do not have to be read one by one
 * from the file and written to the outgoing socket.
 * <p>
 * It implements {@link WriteStream} so it can be used with
 * {@link Pump} to pump data with flow control.
 */
export abstract class HttpServerResponse implements WriteStream<Buffer> {
  /**
   * Same as {@link HttpServerResponse#end} but with an <code>handler</code> called when the operation completes
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link HttpServerResponse#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : HttpServerResponse;

  write(data: Buffer) : HttpServerResponse;

  /**
   * Same as {@link HttpServerResponse#write} but with an <code>handler</code> called when the operation completes
   */
  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  setWriteQueueMaxSize(maxSize: number) : HttpServerResponse;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   */
  getStatusCode() : number;

  /**
   * Set the status code. If the status message hasn't been explicitly set, a default status message corresponding
   * to the code will be looked-up and used.
   */
  setStatusCode(statusCode: number) : HttpServerResponse;

  /**
   */
  getStatusMessage() : string;

  /**
   * Set the status message
   */
  setStatusMessage(statusMessage: string) : HttpServerResponse;

  /**
   * If <code>chunked</code> is <code>true</code>, this response will use HTTP chunked encoding, and each call to write to the body
   * will correspond to a new HTTP chunk sent on the wire.
   * <p>
   * If chunked encoding is used the HTTP header <code>Transfer-Encoding</code> with a value of <code>Chunked</code> will be
   * automatically inserted in the response.
   * <p>
   * If <code>chunked</code> is <code>false</code>, this response will not use HTTP chunked encoding, and therefore the total size
   * of any data that is written in the respone body must be set in the <code>Content-Length</code> header <b>before</b> any
   * data is written out.
   * <p>
   * An HTTP chunked response is typically used when you do not know the total size of the request body up front.
   */
  setChunked(chunked: boolean) : HttpServerResponse;

  /**
   */
  isChunked() : boolean;

  /**
   */
  headers() : MultiMap;

  /**
   * Put an HTTP header
   */
  putHeader(name: string, value: string) : HttpServerResponse;

  /**
   */
  trailers() : MultiMap;

  /**
   * Put an HTTP trailer
   */
  putTrailer(name: string, value: string) : HttpServerResponse;

  /**
   * Set a close handler for the response, this is called when the underlying connection is closed and the response
   * was still using the connection.
   * <p>
   * For HTTP/1.x it is called when the connection is closed before <code>end()</code> is called, therefore it is not
   * guaranteed to be called.
   * <p>
   * For HTTP/2 it is called when the related stream is closed, and therefore it will be always be called.
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Set an end handler for the response. This will be called when the response is disposed to allow consistent cleanup
   * of the response.
   */
  endHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Write a String to the response body, encoded using the encoding <code>enc</code>.
   */
  write(chunk: string, enc: string) : HttpServerResponse;

  /**
   * Same as {@link HttpServerResponse#write} but with an <code>handler</code> called when the operation completes
   */
  write(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Write a String to the response body, encoded in UTF-8.
   */
  write(chunk: string) : HttpServerResponse;

  /**
   * Same as {@link HttpServerResponse#write} but with an <code>handler</code> called when the operation completes
   */
  write(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Used to write an interim 100 Continue response to signify that the client should send the rest of the request.
   * Must only be used if the request contains an "Expect:100-Continue" header
   */
  writeContinue() : HttpServerResponse;

  /**
   * Same as {@link HttpServerResponse#end} but writes a String in UTF-8 encoding before ending the response.
   */
  end(chunk: string) : void;

  /**
   * Same as {@link HttpServerResponse#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link HttpServerResponse#end} but writes a String with the specified encoding before ending the response.
   */
  end(chunk: string, enc: string) : void;

  /**
   * Same as {@link HttpServerResponse#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link HttpServerResponse#end} but writes some data to the response body before ending. If the response is not chunked and
   * no other data has been written then the @code{Content-Length} header will be automatically set.
   */
  end(chunk: Buffer) : void;

  /**
   * Same as {@link HttpServerResponse#end} but with an <code>handler</code> called when the operation completes
   */
  end(chunk: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Ends the response. If no data has been written to the response body,
   * the actual response won't get written until this method gets called.
   * <p>
   * Once the response has ended, it cannot be used any more.
   */
  end() : void;

  /**
   * Same as {@link HttpServerResponse#sendFile} using offset @code{0} which means starting from the beginning of the file.
   */
  sendFile(filename: string) : HttpServerResponse;

  /**
   * Same as {@link HttpServerResponse#sendFile} using length @code{Long.MAX_VALUE} which means until the end of the
   * file.
   */
  sendFile(filename: string, offset: number) : HttpServerResponse;

  /**
   * Ask the OS to stream a file as specified by <code>filename</code> directly
   * from disk to the outgoing connection, bypassing userspace altogether
   * (where supported by the underlying operating system.
   * This is a very efficient way to serve files.<p>
   * The actual serve is asynchronous and may not complete until some time after this method has returned.
   */
  sendFile(filename: string, offset: number, length: number) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#sendFile} but providing a handler which will be notified once the file has been completely
   * written to the wire.
   */
  sendFile(filename: string, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#sendFile} but providing a handler which will be notified once the file has been completely
   * written to the wire.
   */
  sendFile(filename: string, offset: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#sendFile} but providing a handler which will be notified once the file has been
   * completely written to the wire.
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : HttpServerResponse;

  /**
   * Close the underlying TCP connection corresponding to the request.
   */
  close() : void;

  /**
   */
  ended() : boolean;

  /**
   */
  closed() : boolean;

  /**
   */
  headWritten() : boolean;

  /**
   * Provide a handler that will be called just before the headers are written to the wire.<p>
   * This provides a hook allowing you to add any more headers or do any more operations before this occurs.
   */
  headersEndHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   * Provides a handler that will be called after the last part of the body is written to the wire.
   * The handler is called asynchronously of when the response has been received by the client.
   * This provides a hook allowing you to do more operations once the request has been sent over the wire
   * such as resource cleanup.
   */
  bodyEndHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : HttpServerResponse;

  /**
   */
  bytesWritten() : number;

  /**
   */
  streamId() : number;

  /**
   * Like {@link HttpServerResponse#push} with no headers.
   */
  push(method: HttpMethod, host: string, path: string, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#push} with the host copied from the current request.
   */
  push(method: HttpMethod, path: string, headers: MultiMap, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#push} with the host copied from the current request.
   */
  push(method: HttpMethod, path: string, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Push a response to the client.<p/>
   *
   * The <code>handler</code> will be notified with a <i>success</i> when the push can be sent and with
   * a <i>failure</i> when the client has disabled push or reset the push before it has been sent.<p/>
   *
   * The <code>handler</code> may be queued if the client has reduced the maximum number of streams the server can push
   * concurrently.<p/>
   *
   * Push can be sent only for peer initiated streams and if the response is not ended.
   */
  push(method: HttpMethod, host: string, path: string, headers: MultiMap, handler: ((res: AsyncResult<HttpServerResponse>) => void) | Handler<AsyncResult<HttpServerResponse>>) : HttpServerResponse;

  /**
   * Reset this HTTP/2 stream with the error code <code>0</code>.
   */
  reset() : void;

  /**
   * Reset this HTTP/2 stream with the error <code>code</code>.
   */
  reset(code: number) : void;

  /**
   * Write an HTTP/2 frame to the response, allowing to extend the HTTP/2 protocol.<p>
   *
   * The frame is sent immediatly and is not subject to flow control.
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#writeCustomFrame} but with an {@link HttpFrame}.
   */
  writeCustomFrame(frame: HttpFrame) : HttpServerResponse;

  /**
   * Sets the priority of the associated stream
   * <p/>
   * This is not implemented for HTTP/1.x.
   */
  setStreamPriority(streamPriority: StreamPriority) : HttpServerResponse;

  /**
   * Add a cookie. This will be sent back to the client in the response.
   */
  addCookie(cookie: Cookie) : HttpServerResponse;

  /**
   * Expire a cookie, notifying a User Agent to remove it from its cookie jar.
   */
  removeCookie(name: string) : Cookie | null;

  /**
   * Remove a cookie from the cookie set. If invalidate is true then it will expire a cookie, notifying a User Agent to
   * remove it from its cookie jar.
   */
  removeCookie(name: string, invalidate: boolean) : Cookie | null;

  /**
   * Like {@link HttpServerResponse#putHeader} but using CharSequence
   */
  putHeader(name: string, value: string) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#putHeader} but providing multiple values via a String Iterable
   */
  putHeader(name: string, values: any /* java.lang.Iterable<java.lang.String> */) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#putHeader} but with CharSequence Iterable
   */
  putHeader(name: string, values: any /* java.lang.Iterable<java.lang.CharSequence> */) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#putTrailer} but using CharSequence
   */
  putTrailer(name: string, value: string) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#putTrailer} but providing multiple values via a String Iterable
   */
  putTrailer(name: string, values: any /* java.lang.Iterable<java.lang.String> */) : HttpServerResponse;

  /**
   * Like {@link HttpServerResponse#putTrailer} but with CharSequence Iterable
   */
  putTrailer(name: string, value: any /* java.lang.Iterable<java.lang.CharSequence> */) : HttpServerResponse;
}

import { JsonEventType } from './enums';

/**
 * A JSON event emited by the {@link JsonParser}.
 */
export abstract class JsonEvent {
  /**
   */
  type() : JsonEventType;

  /**
   */
  fieldName() : string;

  /**
   */
  value() : any;

  /**
   */
  isNumber() : boolean;

  /**
   */
  integerValue() : number;

  /**
   */
  longValue() : number;

  /**
   */
  floatValue() : number;

  /**
   */
  doubleValue() : number;

  /**
   */
  isBoolean() : boolean;

  /**
   */
  booleanValue() : boolean;

  /**
   */
  isString() : boolean;

  /**
   */
  stringValue() : string;

  /**
   * Return the binary value.
   * <p>
   * JSON itself has no notion of a binary, this extension complies to the RFC-7493, so this method assumes there is a
   * String value with the key and it contains a Base64 encoded binary, which it decodes if found and returns.
   */
  binaryValue() : Buffer;

  /**
   */
  isNull() : boolean;

  /**
   */
  isObject() : boolean;

  /**
   */
  objectValue() : { [key: string]: any };

  /**
   */
  isArray() : boolean;

  /**
   */
  arrayValue() : any[];

  /**
   * Decodes and returns the current value as the specified <code>type</code>.
   */
  mapTo<T>(type: any /* TODO: class */) : T;

  /**
   * Return the <code>Instant</code> value.
   * <p>
   * JSON itself has no notion of a temporal types, this extension complies to the RFC-7493, so this method assumes
   * there is a String value with the key and it contains an ISO 8601 encoded date and time format
   * such as "2017-04-03T10:25:41Z", which it decodes if found and returns.
   */
  instantValue() : Date;

  /**
   * Decodes and returns the current value as the specified <code>type</code>.
   */
  mapTo<T>(type: any /* com.fasterxml.jackson.core.type.TypeReference<T> */) : T;
}

/**
 * A parser class which allows to incrementally parse json elements and emit json parse events instead of parsing a json
 * element fully. This parser is convenient for parsing large json structures.
 * <p/>
 * The parser also parses concatenated json streams or line delimited json streams.
 * <p/>
 * The parser can also parse entire object or array when it is convenient, for instance a very large array
 * of small objects can be parsed efficiently by handling array <i>start</i>/<i>end</i> and <i>object</i>
 * events.
 * <p/>
 * Whenever the parser fails to parse or process the stream, the {@link JsonParser#exceptionHandler} is called with
 * the cause of the failure and the current handling stops. After such event, the parser should not handle data
 * anymore.
 */
export abstract class JsonParser implements Handler<Buffer>, ReadStream<JsonEvent> {
  /**
   * Something has happened, so handle it.
   */
  handle(event: Buffer) : void;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<JsonEvent>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<JsonEvent>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<JsonEvent>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a new <code>JsonParser</code> instance.
   */
  static newParser() : JsonParser;

  /**
   * Create a new <code>JsonParser</code> instance.
   */
  static newParser(stream: ReadStream<Buffer>) : JsonParser;

  /**
   * Handle a <code>Buffer</code>, pretty much like calling {@link Handler#handle}.
   */
  write(buffer: Buffer) : JsonParser;

  /**
   * End the stream, this must be called after all the json stream has been processed.
   */
  end() : void;

  /**
   * Flip the parser to emit a stream of events for each new json object.
   */
  objectEventMode() : JsonParser;

  /**
   * Flip the parser to emit a single value event for each new json object.
   * </p>
   * Json object currently streamed won't be affected.
   */
  objectValueMode() : JsonParser;

  /**
   * Flip the parser to emit a stream of events for each new json array.
   */
  arrayEventMode() : JsonParser;

  /**
   * Flip the parser to emit a single value event for each new json array.
   * </p>
   * Json array currently streamed won't be affected.
   */
  arrayValueMode() : JsonParser;

  pause() : JsonParser;

  resume() : JsonParser;

  fetch(amount: number) : JsonParser;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : JsonParser;

  handler(handler: ((res: JsonEvent) => void) | Handler<JsonEvent> | null | undefined) : JsonParser;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : JsonParser;
}

/**
 * Implementation of <a href="https://tools.ietf.org/html/rfc6901">RFC6901 Json Pointers</a>.
 */
export abstract class JsonPointer {
  /**
   * Return <code>true</code> if the pointer is a root pointer
   */
  isRootPointer() : boolean;

  /**
   * Return <code>true</code> if the pointer is local (URI with only fragment)
   */
  isLocalPointer() : boolean;

  /**
   * Return <code>true</code> if this pointer is a parent pointer of <code>child</code>.
   * <br/>
   * For instance <code>"/properties"</code> pointer is parent pointer of <code>"/properties/parent"</code>
   */
  isParent(child: JsonPointer) : boolean;

  /**
   * Build a <a href="https://tools.ietf.org/html/rfc6901#section-5">string representation</a> of the JSON Pointer
   */
  toString() : string;

  /**
   * Append an unescaped <code>token</code> to this pointer <br/>
   * Note: If you provide escaped path the behaviour is undefined
   */
  append(token: string) : JsonPointer;

  /**
   * Append the <code>index</code> as reference token to JsonPointer
   */
  append(index: number) : JsonPointer;

  /**
   * Append an unescaped list of <code>tokens</code> to JsonPointer <br/>
   * Note: If you provide escaped paths the behaviour is undefined
   */
  append(tokens: string[]) : JsonPointer;

  /**
   * Append all tokens of <code>pointer</code> to this pointer <br/>
   * Note: The base URI of this pointer will remain untouched
   */
  append(pointer: JsonPointer) : JsonPointer;

  /**
   * Remove last reference token of this pointer
   */
  parent() : JsonPointer;

  /**
   * Query <code>objectToQuery</code> using the provided {@link JsonPointerIterator}. <br/>
   * If you need to query Vert.x json data structures, use {@link JsonPointer#queryJson}<br/>
   * Note: if this pointer is a root pointer, this function returns the provided object
   */
  query(objectToQuery: any, iterator: JsonPointerIterator) : any | null;

  /**
   * Query <code>objectToQuery</code> using the provided {@link JsonPointerIterator}. If the query result is null, returns the default. <br/>
   * If you need to query Vert.x json data structures, use {@link JsonPointer#queryJsonOrDefault}<br/>
   * Note: if this pointer is a root pointer, this function returns the provided object
   */
  queryOrDefault(objectToQuery: any, iterator: JsonPointerIterator, defaultValue: any) : any;

  /**
   * Query <code>jsonElement</code>. <br/>
   * Note: if this pointer is a root pointer, this function returns the provided json element
   */
  queryJson(jsonElement: any) : any | null;

  /**
   * Query <code>jsonElement</code>. If the query result is null, returns the default.<br/>
   * Note: if this pointer is a root pointer, this function returns the provided object
   */
  queryJsonOrDefault(jsonElement: any, defaultValue: any) : any | null;

  /**
   * Query <code>objectToQuery</code> tracing each element walked during the query, including the first and the result (if any).<br/>
   * The first element of the list is objectToQuery and the last is the result, or the element before the first null was encountered
   */
  tracedQuery(objectToQuery: any, iterator: JsonPointerIterator) : any[];

  /**
   * Write <code>newElement</code> in <code>objectToWrite</code> using this pointer. The path token "-" is handled as append to end of array <br/>
   * If you need to write in Vert.x json data structures, use {@link JsonPointer#writeJson} (Object)}<br/>
   */
  write(objectToWrite: any, iterator: JsonPointerIterator, newElement: any, createOnMissing: boolean) : any;

  /**
   * Write <code>newElement</code> in <code>jsonElement</code> using this pointer. The path token "-" is handled as append to end of array.
   */
  writeJson(jsonElement: any, newElement: any) : any;

  /**
   * Write <code>newElement</code> in <code>jsonElement</code> using this pointer. The path token "-" is handled as append to end of array.
   */
  writeJson(jsonElement: any, newElement: any, createOnMissing: boolean) : any;

  /**
   * Copy a JsonPointer
   */
  copy() : JsonPointer;

  /**
   * Build an empty JsonPointer
   */
  static create() : JsonPointer;

  /**
   * Build a JsonPointer from a json pointer string
   */
  static from(pointer: string) : JsonPointer;

  /**
   * Build a <a href="https://tools.ietf.org/html/rfc6901#section-6">URI representation</a> of the JSON Pointer
   */
  toURI() : any /* java.net.URI */;

  /**
   * Return the underlying URI without the fragment
   */
  getURIWithoutFragment() : any /* java.net.URI */;

  /**
   * Build a JsonPointer from a URI.
   */
  static fromURI(uri: any /* java.net.URI */) : JsonPointer;
}

/**
 * The JsonPointerIterator is used by the read/write algorithms of the {@link JsonPointer} to read/write the querying data structure <br/>
 *
 * Every method takes the currentValue as parameter, representing the actual value held by the query algorithm.<br/>
 *
 * Implementations of this interface should be stateless, so they can be reused<br/>
 *
 * You can implement this interface to query the structure you want using json pointers
 */
export abstract class JsonPointerIterator {
  /**
   * Instance of a JsonPointerIterator to query Vert.x Json structures
   */
  static readonly JSON_ITERATOR : JsonPointerIterator;

  /**
   */
  isObject(currentValue: any | null | undefined) : boolean;

  /**
   */
  isArray(currentValue: any | null | undefined) : boolean;

  /**
   */
  isNull(currentValue: any | null | undefined) : boolean;

  /**
   */
  objectContainsKey(currentValue: any | null | undefined, key: string) : boolean;

  /**
   * Returns the object parameter with specified key.
   */
  getObjectParameter(currentValue: any | null | undefined, key: string, createOnMissing: boolean) : any;

  /**
   * Move the iterator the the array element at specified index
   */
  getArrayElement(currentValue: any | null | undefined, i: number) : any;

  /**
   * Write object parameter at specified key
   */
  writeObjectParameter(currentValue: any | null | undefined, key: string, value: any | null | undefined) : boolean;

  /**
   * Write array element at specified index
   */
  writeArrayElement(currentValue: any | null | undefined, i: number, value: any | null | undefined) : boolean;

  /**
   * Append array element
   */
  appendArrayElement(currentValue: any | null | undefined, value: any | null | undefined) : boolean;
}

/**
 * Local maps can be used to share data safely in a single Vert.x instance.
 * <p>
 * By default the map allows immutable keys and values.
 * Custom keys and values should implement {@link Shareable} interface. The map returns their copies.
 * <p>
 * This ensures there is no shared access to mutable state from different threads (e.g. different event loops) in the
 * Vert.x instance, and means you don't have to protect access to that state using synchronization or locks.
 * <p>
 *
 * Since the version 3.4, this class extends the  interface. However some methods are only accessible in Java.
 */
export abstract class LocalMap<K, V> {
  /**
   * Get a value from the map
   */
  get(key: any) : V;

  /**
   * Put an entry in the map
   */
  put(key: K, value: V) : V;

  /**
   * Remove an entry from the map
   */
  remove(key: any) : V;

  /**
   * Clear all entries in the map
   */
  clear() : void;

  /**
   * Get the size of the map
   */
  size() : number;

  /**
   */
  isEmpty() : boolean;

  /**
   * Put the entry only if there is no existing entry for that key
   */
  putIfAbsent(key: K, value: V) : V;

  /**
   * Remove the entry only if there is an entry with the specified key and value.
   * <p>
   * This method is the poyglot version of {@link LocalMap#remove}.
   */
  removeIfPresent(key: K, value: V) : boolean;

  /**
   * Replace the entry only if there is an existing entry with the specified key and value.
   * <p>
   * This method is the polyglot version of {@link LocalMap#replace}.
   */
  replaceIfPresent(key: K, oldValue: V, newValue: V) : boolean;

  /**
   * Replace the entry only if there is an existing entry with the key
   */
  replace(key: K, value: V) : V;

  /**
   * Close and release the map
   */
  close() : void;

  /**
   * Returns <code>true</code> if this map contains a mapping for the specified
   * key.
   */
  containsKey(key: any) : boolean;

  /**
   * Returns @{code true} if this map maps one or more keys to the
   * specified value.
   */
  containsValue(value: any) : boolean;

  /**
   * Returns the value to which the specified key is mapped, or
   * <code>defaultValue</code> if this map contains no mapping for the key.
   */
  getOrDefault(key: any, defaultValue: V) : V;
}

/**
 * An asynchronous exclusive lock which can be obtained from any node in the cluster.
 * <p>
 * When the lock is obtained, no-one else in the cluster can obtain the lock with the same name until the lock
 * is released.
 */
export abstract class Lock {
  /**
   * Release the lock. Once the lock is released another will be able to obtain the lock.
   */
  release() : void;
}

/**
 */
export interface Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;
}

/**
 * Represents a message that is received from the event bus in a handler.
 * <p>
 * Messages have a {@link Message#body}, which can be null, and also {@link Message#headers}, which can be empty.
 * <p>
 * If the message was sent specifying a reply handler, it can be replied to using {@link Message#reply}.
 * <p>
 * If you want to notify the sender that processing failed, then {@link Message#fail} can be called.
 */
export abstract class Message<T> {
  /**
   * The address the message was sent to
   */
  address() : string;

  /**
   * Multi-map of message headers. Can be empty
   */
  headers() : MultiMap;

  /**
   * The body of the message. Can be null.
   */
  body() : T;

  /**
   * The reply address. Can be null.
   */
  replyAddress() : string | null;

  /**
   * Signals if this message represents a send or publish event.
   */
  isSend() : boolean;

  /**
   * Reply to this message.
   * <p>
   * If the message was sent specifying a reply handler, that handler will be
   * called when it has received a reply. If the message wasn't sent specifying a receipt handler
   * this method does nothing.
   */
  reply(message: any) : void;

  /**
   * The same as <code>reply(R message)</code> but you can specify handler for the reply - i.e.
   * to receive the reply to the reply.
   */
  reply<R>(message: any | null | undefined, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Link {@link Message#reply} but allows you to specify delivery options for the reply.
   */
  reply(message: any | null | undefined, options: DeliveryOptions) : void;

  /**
   * The same as <code>reply(R message, DeliveryOptions)</code> but you can specify handler for the reply - i.e.
   * to receive the reply to the reply.
   */
  reply<R>(message: any | null | undefined, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Reply to this message, specifying a <code>replyHandler</code> for the reply - i.e.
   * to receive the reply to the reply.
   * <p>
   * If the message was sent specifying a reply handler, that handler will be
   * called when it has received a reply. If the message wasn't sent specifying a receipt handler
   * this method does nothing.
   */
  replyAndRequest<R>(message: any | null | undefined, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Like  but specifying <code>options</code> that can be used
   * to configure the delivery.
   */
  replyAndRequest<R>(message: any | null | undefined, options: DeliveryOptions, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : void;

  /**
   * Signal to the sender that processing of this message failed.
   * <p>
   * If the message was sent specifying a result handler
   * the handler will be called with a failure corresponding to the failure code and message specified here.
   */
  fail(failureCode: number, message: string) : void;
}

/**
 * An event bus consumer object representing a stream of message to an {@link EventBus} address that can
 * be read from.
 * <p>
 * The {@link EventBus#consumer} or {@link EventBus#localConsumer}
 * creates a new consumer, the returned consumer is not yet registered against the event bus. Registration
 * is effective after the {@link MessageConsumer#handler} method is invoked.<p>
 *
 * The consumer is unregistered from the event bus using the {@link MessageConsumer#unregister} method or by calling the
 * {@link MessageConsumer#handler} with a null value..
 */
export abstract class MessageConsumer<T> implements ReadStream<Message<T>> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Message<T>>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Message<T>>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Message<T>>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : MessageConsumer<T>;

  handler(handler: ((res: Message<T>) => void) | Handler<Message<T>> | null | undefined) : MessageConsumer<T>;

  pause() : MessageConsumer<T>;

  resume() : MessageConsumer<T>;

  fetch(amount: number) : MessageConsumer<T>;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : MessageConsumer<T>;

  /**
   */
  bodyStream() : ReadStream<T>;

  /**
   */
  isRegistered() : boolean;

  /**
   */
  address() : string;

  /**
   * Set the number of messages this registration will buffer when this stream is paused. The default
   * value is <code>1000</code>.
   * <p>
   * When a new value is set, buffered messages may be discarded to reach the new value. The most recent
   * messages will be kept.
   */
  setMaxBufferedMessages(maxBufferedMessages: number) : MessageConsumer<T>;

  /**
   */
  getMaxBufferedMessages() : number;

  /**
   * Optional method which can be called to indicate when the registration has been propagated across the cluster.
   */
  completionHandler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Unregisters the handler which created this registration
   */
  unregister() : void;

  /**
   * Unregisters the handler which created this registration
   */
  unregister(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

/**
 * Represents a stream of message that can be written to.
 * <p>
 */
export abstract class MessageProducer<T> implements WriteStream<T> {
  static readonly DEFAULT_WRITE_QUEUE_MAX_SIZE : number;

  /**
   * Same as {@link MessageProducer#end} but writes some data to the stream before ending.
   */
  end(data: T) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link MessageProducer#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * This method actually sends a message using the send semantic regardless this producer
   * is a sender or a publisher.
   */
  send(message: T) : MessageProducer<T>;

  /**
   * Like {@link MessageProducer#send} but specifying a <code>replyHandler</code> that will be called if the recipient
   * subsequently replies to the message.
   */
  send<R>(message: T, replyHandler: ((res: AsyncResult<Message<R>>) => void) | Handler<AsyncResult<Message<R>>>) : MessageProducer<T>;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : MessageProducer<T>;

  write(data: T) : MessageProducer<T>;

  write(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : MessageProducer<T>;

  setWriteQueueMaxSize(maxSize: number) : MessageProducer<T>;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : MessageProducer<T>;

  /**
   * Update the delivery options of this producer.
   */
  deliveryOptions(options: DeliveryOptions) : MessageProducer<T>;

  /**
   */
  address() : string;

  /**
   * Closes the producer, calls {@link MessageProducer#close}
   */
  end() : void;

  /**
   * Closes the producer, calls {@link MessageProducer#close}
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Closes the producer, this method should be called when the message producer is not used anymore.
   */
  close() : void;

  /**
   * Same as {@link MessageProducer#close} but with an <code>handler</code> called when the operation completes
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

/**
 * This class represents a MultiMap of String keys to a List of String values.
 * <p>
 * It's useful in Vert.x to represent things in Vert.x like HTTP headers and HTTP parameters which allow
 * multiple values for keys.
 */
export abstract class MultiMap {
  /**
   * Create a multi-map implementation with case insensitive keys, for instance it can be used to hold some HTTP headers.
   */
  static caseInsensitiveMultiMap() : MultiMap;

  /**
   * Returns the value of with the specified name.  If there are
   * more than one values for the specified name, the first value is returned.
   */
  get(name: string) : string | null;

  /**
   * Returns the values with the specified name
   */
  getAll(name: string) : string[];

  /**
   * Checks to see if there is a value with the specified name
   */
  contains(name: string) : boolean;

  /**
   * Check if there is a header with the specified <code>name</code> and <code>value</code>.
   *
   * If <code>caseInsensitive</code> is <code>true</code>, <code>value</code> is compared in a case-insensitive way.
   */
  contains(name: string, value: string, caseInsensitive: boolean) : boolean;

  /**
   * Return true if empty
   */
  isEmpty() : boolean;

  /**
   * Gets a immutable Set of all names
   */
  names() : string[];

  /**
   * Adds a new value with the specified name and value.
   */
  add(name: string, value: string) : MultiMap;

  /**
   * Adds all the entries from another MultiMap to this one
   */
  addAll(map: MultiMap) : MultiMap;

  /**
   * Sets a <code>value</code> under the specified <code>name</code>.
   * <p>
   * If there is an existing header with the same name, it is removed. Setting a <code>null</code> value removes the entry.
   */
  set(name: string, value: string) : MultiMap;

  /**
   * Cleans this instance.
   */
  setAll(map: MultiMap) : MultiMap;

  /**
   * Removes the value with the given name
   */
  remove(name: string) : MultiMap;

  /**
   * Removes all
   */
  clear() : MultiMap;

  /**
   * Return the number of keys.
   */
  size() : number;

  get(name: string) : string;

  /**
   * Like {@link MultiMap#getAll} but accepting a <code>CharSequence</code> as a parameter
   */
  getAll(name: string) : string[];

  /**
   * Returns all entries in the multi-map.
   */
  entries() : any /* java.util.Map.Entry<java.lang.String,java.lang.String> */[];

  /**
   * Like {@link MultiMap#contains} but accepting a <code>CharSequence</code> as a parameter
   */
  contains(name: string) : boolean;

  /**
   * Like {@link MultiMap#contains} but accepting <code>CharSequence</code> parameters.
   */
  contains(name: string, value: string, caseInsensitive: boolean) : boolean;

  /**
   * Like {@link MultiMap#add} but accepting <code>CharSequence</code> as parameters
   */
  add(name: string, value: string) : MultiMap;

  /**
   * Adds a new values under the specified name
   */
  add(name: string, values: any /* java.lang.Iterable<java.lang.String> */) : MultiMap;

  /**
   * Like {@link MultiMap#add} but accepting <code>CharSequence</code> as parameters
   */
  add(name: string, values: any /* java.lang.Iterable<java.lang.CharSequence> */) : MultiMap;

  /**
   * Adds all the entries from a Map to this
   */
  addAll(headers: { [key: string]: string; }) : MultiMap;

  /**
   * Like {@link MultiMap#set} but accepting <code>CharSequence</code> as parameters
   */
  set(name: string, value: string) : MultiMap;

  /**
   * Sets values for the specified name.
   */
  set(name: string, values: any /* java.lang.Iterable<java.lang.String> */) : MultiMap;

  /**
   * Like {@link MultiMap#set} but accepting <code>CharSequence</code> as parameters
   */
  set(name: string, values: any /* java.lang.Iterable<java.lang.CharSequence> */) : MultiMap;

  /**
   * Cleans and set all values of the given instance
   */
  setAll(headers: { [key: string]: string; }) : MultiMap;

  /**
   * Like {@link MultiMap#remove} but accepting <code>CharSequence</code> as parameters
   */
  remove(name: string) : MultiMap;
}

/**
 * Represent a Mail-Exchange-Record (MX) which was resolved for a domain.
 */
export abstract class MxRecord {
  /**
   * The priority of the MX record.
   */
  priority() : number;

  /**
   * The name of the MX record
   */
  name() : string;
}

/**
 * A TCP client.
 * <p>
 * Multiple connections to different servers can be made using the same instance.
 * <p>
 * This client supports a configurable number of connection attempts and a configurable
 * delay between attempts.
 */
export abstract class NetClient implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Open a connection to a server at the specific <code>port</code> and <code>host</code>.
   * <p>
   * <code>host</code> can be a valid host name or IP address. The connect is done asynchronously and on success, a
   * {@link NetSocket} instance is supplied via the <code>connectHandler</code> instance
   */
  connect(port: number, host: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific <code>port</code> and <code>host</code>.
   * <p>
   * <code>host</code> can be a valid host name or IP address. The connect is done asynchronously and on success, a
   * {@link NetSocket} instance is supplied via the <code>connectHandler</code> instance
   */
  connect(port: number, host: string, serverName: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific <code>remoteAddress</code>.
   * <p>
   * The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the <code>connectHandler</code> instance
   */
  connect(remoteAddress: SocketAddress, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Open a connection to a server at the specific <code>remoteAddress</code>.
   * <p>
   * The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the <code>connectHandler</code> instance
   */
  connect(remoteAddress: SocketAddress, serverName: string, connectHandler: ((res: AsyncResult<NetSocket>) => void) | Handler<AsyncResult<NetSocket>>) : NetClient;

  /**
   * Close the client.
   * <p>
   * Any sockets which have not been closed manually will be closed here. The close is asynchronous and may not
   * complete until some time after the method has returned.
   */
  close() : void;
}

/**
 * Represents a TCP server
 */
export abstract class NetServer implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Return the connect stream for this server. The server can only have at most one handler at any one time.
   * As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   * connect stream .
   */
  connectStream() : ReadStream<NetSocket>;

  /**
   * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.
   * As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   * connect handler.
   */
  connectHandler(handler: ((res: NetSocket) => void) | Handler<NetSocket> | null | undefined) : NetServer;

  /**
   * Start listening on the port and host as configured in the <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a> used when
   * creating the server.
   * <p>
   * The server may not be listening until some time after the call to listen has returned.
   */
  listen() : NetServer;

  /**
   * Like {@link NetServer#listen} but providing a handler that will be notified when the server is listening, or fails.
   */
  listen(listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified port and host, ignoring port and host configured in the <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a> used when
   * creating the server.
   * <p>
   * Port <code>0</code> can be specified meaning "choose an random port".
   * <p>
   * Host <code>0.0.0.0</code> can be specified meaning "listen on all available interfaces".
   * <p>
   * The server may not be listening until some time after the call to listen has returned.
   */
  listen(port: number, host: string) : NetServer;

  /**
   * Like {@link NetServer#listen} but providing a handler that will be notified when the server is listening, or fails.
   */
  listen(port: number, host: string, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified port and host "0.0.0.0", ignoring port and host configured in the
   * <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a> used when creating the server.
   * <p>
   * Port <code>0</code> can be specified meaning "choose an random port".
   * <p>
   * The server may not be listening until some time after the call to listen has returned.
   */
  listen(port: number) : NetServer;

  /**
   * Like {@link NetServer#listen} but providing a handler that will be notified when the server is listening, or fails.
   */
  listen(port: number, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Start listening on the specified local address, ignoring port and host configured in the <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a> used when
   * creating the server.
   * <p>
   * The server may not be listening until some time after the call to listen has returned.
   */
  listen(localAddress: SocketAddress) : NetServer;

  /**
   * Like {@link NetServer#listen} but providing a handler that will be notified when the server is listening, or fails.
   */
  listen(localAddress: SocketAddress, listenHandler: ((res: AsyncResult<NetServer>) => void) | Handler<AsyncResult<NetServer>>) : NetServer;

  /**
   * Close the server. This will close any currently open connections. The close may not complete until after this
   * method has returned.
   */
  close() : void;

  /**
   * Like {@link NetServer#close} but supplying a handler that will be notified when close is complete.
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   * signifying an ephemeral port
   */
  actualPort() : number;
}

/**
 * Represents a socket-like interface to a TCP connection on either the
 * client or the server side.
 * <p>
 * Instances of this class are created on the client side by an {@link NetClient}
 * when a connection to a server is made, or on the server side by a {@link NetServer}
 * when a server accepts a connection.
 * <p>
 * It implements both  and  so it can be used with
 * {@link Pump} to pump data with flow control.
 */
export abstract class NetSocket implements ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link NetSocket#end} but writes some data to the stream before ending.
   */
  end(data: Buffer) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link NetSocket#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : NetSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : NetSocket;

  pause() : NetSocket;

  resume() : NetSocket;

  fetch(amount: number) : NetSocket;

  /**
   * 
   * <p>
   * This handler might be called after the close handler when the socket is paused and there are still
   * buffers to deliver.
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  write(data: Buffer) : NetSocket;

  setWriteQueueMaxSize(maxSize: number) : NetSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  /**
   * When a <code>NetSocket</code> is created it automatically registers an event handler with the event bus, the ID of that
   * handler is given by <code>writeHandlerID</code>.
   * <p>
   * Given this ID, a different event loop can send a buffer to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other connections which are owned by different event loops.
   */
  writeHandlerID() : string;

  /**
   * Same as {@link NetSocket#write} but with an <code>handler</code> called when the operation completes
   */
  write(str: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Write a String to the connection, encoded in UTF-8.
   */
  write(str: string) : NetSocket;

  /**
   * Same as {@link NetSocket#write} but with an <code>handler</code> called when the operation completes
   */
  write(str: string, enc: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Write a String to the connection, encoded using the encoding <code>enc</code>.
   */
  write(str: string, enc: string) : NetSocket;

  /**
   * Like  but with an <code>handler</code> called when the message has been written
   * or failed to be written.
   */
  write(message: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by <code>filename</code> directly from disk to the outgoing connection,
   * bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   */
  sendFile(filename: string) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by <code>filename</code> directly from disk to the outgoing connection,
   * bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   */
  sendFile(filename: string, offset: number) : NetSocket;

  /**
   * Tell the operating system to stream a file as specified by <code>filename</code> directly from disk to the outgoing connection,
   * bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   */
  sendFile(filename: string, offset: number, length: number) : NetSocket;

  /**
   * Same as {@link NetSocket#sendFile} but also takes a handler that will be called when the send has completed or
   * a failure has occurred
   */
  sendFile(filename: string, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Same as {@link NetSocket#sendFile} but also takes a handler that will be called when the send has completed or
   * a failure has occurred
   */
  sendFile(filename: string, offset: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   * Same as {@link NetSocket#sendFile} but also takes a handler that will be called when the send has completed or
   * a failure has occurred
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : NetSocket;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   * Calls {@link NetSocket#close}
   */
  end() : void;

  /**
   * Calls {@link NetSocket#end}
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the NetSocket
   */
  close() : void;

  /**
   * Close the NetSocket and notify the <code>handler</code> when the operation completes.
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set a handler that will be called when the NetSocket is closed
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : NetSocket;

  /**
   * Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   */
  upgradeToSsl(handler: ((res: void) => void) | Handler<void>) : NetSocket;

  /**
   * Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   */
  upgradeToSsl(serverName: string, handler: ((res: void) => void) | Handler<void>) : NetSocket;

  /**
   */
  isSsl() : boolean;

  /**
   * Returns the SNI server name presented during the SSL handshake by the client.
   */
  indicatedServerName() : string;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * Pipe data from a {@link ReadStream} to a {@link WriteStream} and performs flow control where necessary to
 * prevent the write stream buffer from getting overfull.
 * <p>
 * Instances of this class read items from a {@link ReadStream} and write them to a {@link WriteStream}. If data
 * can be read faster than it can be written this could result in the write queue of the {@link WriteStream} growing
 * without bound, eventually causing it to exhaust all available RAM.
 * <p>
 * To prevent this, after each write, instances of this class check whether the write queue of the {@link WriteStream} is full, and if so, the {@link ReadStream} is paused, and a <code>drainHandler</code> is set on the
 * {@link WriteStream}.
 * <p>
 * When the {@link WriteStream} has processed half of its backlog, the <code>drainHandler</code> will be
 * called, which results in the pump resuming the {@link ReadStream}.
 * <p>
 * This class can be used to pipe from any {@link ReadStream} to any {@link WriteStream},
 * e.g. from an {@link HttpServerRequest} to an {@link AsyncFile},
 * or from {@link NetSocket} to a {@link WebSocket}.
 * <p>
 * Please see the documentation for more information.
 */
export abstract class Pipe<T> {
  /**
   * Set to <code>true</code> to call {@link WriteStream#end} when the source <code>ReadStream</code> fails, <code>false</code> otherwise.
   */
  endOnFailure(end: boolean) : Pipe<T>;

  /**
   * Set to <code>true</code> to call {@link WriteStream#end} when the source <code>ReadStream</code> succeeds, <code>false</code> otherwise.
   */
  endOnSuccess(end: boolean) : Pipe<T>;

  /**
   * Set to <code>true</code> to call {@link WriteStream#end} when the source <code>ReadStream</code> completes, <code>false</code> otherwise.
   * <p>
   * Calling this overwrites {@link Pipe#endOnFailure} and {@link Pipe#endOnSuccess}.
   */
  endOnComplete(end: boolean) : Pipe<T>;

  /**
   * Like {@link Pipe#to} but without a completion handler
   */
  to(dst: WriteStream<T>) : void;

  /**
   * Start to pipe the elements to the destination <code>WriteStream</code>.
   * <p>
   * When the operation fails with a write error, the source stream is resumed.
   */
  to(dst: WriteStream<T>, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the pipe.
   * <p>
   * The streams handlers will be unset and the read stream resumed unless it is already ended.
   */
  close() : void;
}

/**
 * Represents the writable side of an action that may, or may not, have occurred yet.
 * <p>
 * The {@link Promise#future} method returns the {@link Future} associated with a promise, the future
 * can be used for getting notified of the promise completion and retrieve its value.
 * <p>
 * A promise extends <code>Handler<AsyncResult<T>></code> so it can be used as a callback.
 */
export abstract class Promise<T> {
  /**
   * Create a promise that hasn't completed yet
   */
  static promise<T>() : Promise<T>;

  /**
   * Set the result. Any handler will be called, if there is one, and the promise will be marked as completed.
   * <p/>
   * Any handler set on the associated promise will be called.
   */
  complete(result: T) : void;

  /**
   * Calls <code>complete(null)</code>
   */
  complete() : void;

  /**
   * Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   */
  fail(cause: Throwable | Error) : void;

  /**
   * Calls {@link Promise#fail} with the <code>message</code>.
   */
  fail(message: string) : void;

  /**
   * Like {@link Promise#complete} but returns <code>false</code> when the promise is already completed instead of throwing
   * an IllegalStateException, it returns <code>true</code> otherwise.
   */
  tryComplete(result: T) : boolean;

  /**
   * Calls <code>tryComplete(null)</code>.
   */
  tryComplete() : boolean;

  /**
   * Like {@link Promise#fail} but returns <code>false</code> when the promise is already completed instead of throwing
   * an IllegalStateException, it returns <code>true</code> otherwise.
   */
  tryFail(cause: Throwable | Error) : boolean;

  /**
   * Calls {@link Promise#fail} with the <code>message</code>.
   */
  tryFail(message: string) : boolean;

  /**
   */
  future() : Future<T>;
}

/**
 * Pumps data from a {@link ReadStream} to a {@link WriteStream} and performs flow control where necessary to
 * prevent the write stream buffer from getting overfull.
 * <p>
 * Instances of this class read items from a {@link ReadStream} and write them to a {@link WriteStream}. If data
 * can be read faster than it can be written this could result in the write queue of the {@link WriteStream} growing
 * without bound, eventually causing it to exhaust all available RAM.
 * <p>
 * To prevent this, after each write, instances of this class check whether the write queue of the {@link WriteStream} is full, and if so, the {@link ReadStream} is paused, and a <code>drainHandler</code> is set on the
 * {@link WriteStream}.
 * <p>
 * When the {@link WriteStream} has processed half of its backlog, the <code>drainHandler</code> will be
 * called, which results in the pump resuming the {@link ReadStream}.
 * <p>
 * This class can be used to pump from any {@link ReadStream} to any {@link WriteStream},
 * e.g. from an {@link HttpServerRequest} to an {@link AsyncFile},
 * or from {@link NetSocket} to a {@link WebSocket}.
 * <p>
 * Please see the documentation for more information.
 */
export abstract class Pump {
  /**
   * Create a new <code>Pump</code> with the given <code>ReadStream</code> and <code>WriteStream</code>
   */
  static pump<T>(rs: ReadStream<T>, ws: WriteStream<T>) : Pump;

  /**
   * Create a new <code>Pump</code> with the given <code>ReadStream</code> and <code>WriteStream</code> and
   * <code>writeQueueMaxSize</code>
   */
  static pump<T>(rs: ReadStream<T>, ws: WriteStream<T>, writeQueueMaxSize: number) : Pump;

  /**
   * Set the write queue max size to <code>maxSize</code>
   */
  setWriteQueueMaxSize(maxSize: number) : Pump;

  /**
   * Start the Pump. The Pump can be started and stopped multiple times.
   */
  start() : Pump;

  /**
   * Stop the Pump. The Pump can be started and stopped multiple times.
   */
  stop() : Pump;

  /**
   * Return the total number of items pumped by this pump.
   */
  numberPumped() : number;
}

/**
 * Represents a stream of items that can be read from.
 * <p>
 * Any class that implements this interface can be used by a {@link Pump} to pump data from it
 * to a {@link WriteStream}.
 * <p>
 * <h3>Streaming mode</h3>
 * The stream is either in <i>flowing</i> or <i>fetch</i> mode.
 * <ul>
 *   <i>Initially the stream is in <i>flowing</i> mode.</i>
 *   <li>When the stream is in <i>flowing</i> mode, elements are delivered to the <code>handler</code>.</li>
 *   <li>When the stream is in <i>fetch</i> mode, only the number of requested elements will be delivered to the <code>handler</code>.</li>
 * </ul>
 * The mode can be changed with the {@link ReadStream#pause}, {@link ReadStream#resume} and {@link ReadStream#fetch} methods:
 * <ul>
 *   <li>Calling {@link ReadStream#resume} sets the <i>flowing</i> mode</li>
 *   <li>Calling {@link ReadStream#pause} sets the <i>fetch</i> mode and resets the demand to <code>0</code></li>
 *   <li>Calling {@link ReadStream#fetch} requests a specific amount of elements and adds it to the actual demand</li>
 * </ul>
 */
export interface ReadStream<T> extends StreamBase {
  /**
   * Set an exception handler on the read stream.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : ReadStream<T>;

  /**
   * Set a data handler. As data is read, the handler will be called with the data.
   */
  handler(handler: ((res: T) => void) | Handler<T> | null | undefined) : ReadStream<T>;

  /**
   * Pause the <code>ReadStream</code>, it sets the buffer in <code>fetch</code> mode and clears the actual demand.
   * <p>
   * While it's paused, no data will be sent to the data <code>handler</code>.
   */
  pause() : ReadStream<T>;

  /**
   * Resume reading, and sets the buffer in <code>flowing</code> mode.
   * <p/>
   * If the <code>ReadStream</code> has been paused, reading will recommence on it.
   */
  resume() : ReadStream<T>;

  /**
   * Fetch the specified <code>amount</code> of elements. If the <code>ReadStream</code> has been paused, reading will
   * recommence with the specified <code>amount</code> of items, otherwise the specified <code>amount</code> will
   * be added to the current stream demand.
   */
  fetch(amount: number) : ReadStream<T>;

  /**
   * Set an end handler. Once the stream has ended, and there is no more data to be read, this handler will be called.
   */
  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : ReadStream<T>;

  /**
   * Pause this stream and return a {@link Pipe} to transfer the elements of this stream to a destination {@link WriteStream}.
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<T>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<T>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<T>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

/**
 * A helper class which allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed
 * size records.
 * <p>
 * Instances of this class take as input {@link Buffer} instances containing raw bytes,
 * and output records.
 * <p>
 * For example, if I had a simple ASCII text protocol delimited by '\n' and the input was the following:
 * <p>
 * <pre>
 * buffer1:HELLO\nHOW ARE Y
 * buffer2:OU?\nI AM
 * buffer3: DOING OK
 * buffer4:\n
 * </pre>
 * Then the output would be:<p>
 * <pre>
 * buffer1:HELLO
 * buffer2:HOW ARE YOU?
 * buffer3:I AM DOING OK
 * </pre>
 * Instances of this class can be changed between delimited mode and fixed size record mode on the fly as
 * individual records are read, this allows you to parse protocols where, for example, the first 5 records might
 * all be fixed size (of potentially different sizes), followed by some delimited records, followed by more fixed
 * size records.
 * <p>
 * Instances of this class can't currently be used for protocols where the text is encoded with something other than
 * a 1-1 byte-char mapping.
 * <p>
 * Please see the documentation for more information.
 */
export abstract class RecordParser implements Handler<Buffer>, ReadStream<Buffer> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  setOutput(output: ((res: Buffer) => void) | Handler<Buffer>) : void;

  /**
   * Like {@link RecordParser#newDelimited} but set the <code>output</code> that will receive whole records
   * which have been parsed.
   */
  static newDelimited(delim: string, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link RecordParser#newDelimited} but wraps the <code>stream</code>. The <code>stream</code> handlers will be set/unset
   * when the {@link RecordParser#handler} is set.
   * <p/>
   * The <code>pause()</code>/<code>resume()</code> operations are propagated to the <code>stream</code>.
   */
  static newDelimited(delim: string, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Create a new <code>RecordParser</code> instance, initially in delimited mode, and where the delimiter can be represented
   * by the String <code></code> delim endcoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   * <p>
   * <code>output</code> Will receive whole records which have been parsed.
   */
  static newDelimited(delim: string) : RecordParser;

  /**
   * Create a new <code>RecordParser</code> instance, initially in delimited mode, and where the delimiter can be represented
   * by the <code>Buffer</code> delim.
   * <p>
   */
  static newDelimited(delim: Buffer) : RecordParser;

  /**
   * Like {@link RecordParser#newDelimited} but set the <code>output</code> that will receive whole records
   * which have been parsed.
   */
  static newDelimited(delim: Buffer, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link RecordParser#newDelimited} but wraps the <code>stream</code>. The <code>stream</code> handlers will be set/unset
   * when the {@link RecordParser#handler} is set.
   * <p/>
   * The <code>pause()</code>/<code>resume()</code> operations are propagated to the <code>stream</code>.
   */
  static newDelimited(delim: Buffer, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Create a new <code>RecordParser</code> instance, initially in fixed size mode, and where the record size is specified
   * by the <code>size</code> parameter.
   * <p>
   * <code>output</code> Will receive whole records which have been parsed.
   */
  static newFixed(size: number) : RecordParser;

  /**
   * Like {@link RecordParser#newFixed} but set the <code>output</code> that will receive whole records
   * which have been parsed.
   */
  static newFixed(size: number, output: ((res: Buffer) => void) | Handler<Buffer>) : RecordParser;

  /**
   * Like {@link RecordParser#newFixed} but wraps the <code>stream</code>. The <code>stream</code> handlers will be set/unset
   * when the {@link RecordParser#handler} is set.
   * <p/>
   * The <code>pause()</code>/<code>resume()</code> operations are propagated to the <code>stream</code>.
   */
  static newFixed(size: number, stream: ReadStream<Buffer>) : RecordParser;

  /**
   * Flip the parser into delimited mode, and where the delimiter can be represented
   * by the String <code>delim</code> encoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   * <p>
   * This method can be called multiple times with different values of delim while data is being parsed.
   */
  delimitedMode(delim: string) : void;

  /**
   * Flip the parser into delimited mode, and where the delimiter can be represented
   * by the delimiter <code>delim</code>.
   * <p>
   * This method can be called multiple times with different values of delim while data is being parsed.
   */
  delimitedMode(delim: Buffer) : void;

  /**
   * Flip the parser into fixed size mode, where the record size is specified by <code>size</code> in bytes.
   * <p>
   * This method can be called multiple times with different values of size while data is being parsed.
   */
  fixedSizeMode(size: number) : void;

  /**
   * Set the maximum allowed size for a record when using the delimited mode.
   * The delimiter itself does not count for the record size.
   * <p>
   * If a record is longer than specified, an IllegalStateException will be thrown.
   */
  maxRecordSize(size: number) : RecordParser;

  /**
   * This method is called to provide the parser with data.
   */
  handle(buffer: Buffer) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : RecordParser;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : RecordParser;

  pause() : RecordParser;

  fetch(amount: number) : RecordParser;

  resume() : RecordParser;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : RecordParser;
}

import { PemKeyCertOptions } from './options';
import { PemTrustOptions } from './options';

/**
 * A self-signed certificate helper for testing and development purposes.
 * <p>
 * While it helps for testing and development, it should never ever be used in production settings.
 */
export abstract class SelfSignedCertificate {
  /**
   * Provides the {@link KeyCertOptions} RSA private key file in PEM format corresponding to the {@link SelfSignedCertificate#privateKeyPath}
   */
  keyCertOptions() : PemKeyCertOptions;

  /**
   * Provides the {@link TrustOptions} X.509 certificate file in PEM format corresponding to the {@link SelfSignedCertificate#certificatePath}
   */
  trustOptions() : PemTrustOptions;

  /**
   * Filesystem path to the RSA private key file in PEM format
   */
  privateKeyPath() : string;

  /**
   * Filesystem path to the X.509 certificate file in PEM format .
   */
  certificatePath() : string;

  /**
   * Delete the private key and certificate files.
   */
  delete() : void;

  /**
   * Create a new <code>SelfSignedCertificate</code> instance.
   */
  static create() : SelfSignedCertificate;

  /**
   * Create a new <code>SelfSignedCertificate</code> instance with a fully-qualified domain name,
   */
  static create(fqdn: string) : SelfSignedCertificate;
}

/**
 * Represents a server side WebSocket.
 * <p>
 * Instances of this class are passed into a {@link HttpServer#webSocketHandler} or provided
 * when a WebSocket handshake is manually {@link HttpServerRequest#upgrade}ed.
 */
export abstract class ServerWebSocket implements WebSocketBase {
  /**
   * Same as {@link WebSocketBase#end} but writes some data to the stream before ending.
   */
  end(data: Buffer) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link ServerWebSocket#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the event bus - the ID of that
   * handler is given by this method.
   * <p>
   * Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  binaryHandlerID() : string;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the eventbus, the ID of that
   * handler is given by <code>textHandlerID</code>.
   * <p>
   * Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   * <p/>
   * On the server, the value will be <code>null</code> when the handler receives the websocket callback as the
   * handshake will not be completed yet.
   */
  subProtocol() : string;

  /**
   * Returns the close status code received from the remote endpoint or <code>null</code> when not yet received.
   */
  closeStatusCode() : number;

  /**
   * Returns the close reason message from the remote endpoint or <code>null</code> when not yet received.
   */
  closeReason() : string;

  /**
   *  Returns the HTTP headers when the WebSocket is first obtained in the handler.
   *  <p/>
   *  The headers will be <code>null</code> on subsequent interactions.
   */
  headers() : MultiMap;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no handler for ping frames because RFC 6455  clearly
   * states that the only response to a ping frame is a pong frame with identical contents.
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   * automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   * to implement a one way heartbeat.
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   * , but the buffer will be converted to a String first
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link ServerWebSocket#handler}
   * except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   * into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal} to find the boundaries).
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   * on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   * specify whether the client or server sends a ping.
   * <p>
   * Pong frames may be at most 125 bytes (octets).
   * <p>
   * There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   * <p>
   * Pong frames may be received unsolicited.
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link ServerWebSocket#close}
   */
  end() : void;

  /**
   * Calls {@link WebSocketBase#close}
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link ServerWebSocket#close} but with an <code>handler</code> called when the operation completes
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link WebSocketBase#close} but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   */
  isSsl() : boolean;

  /**
   */
  isClosed() : boolean;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : ServerWebSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : ServerWebSocket;

  pause() : ServerWebSocket;

  resume() : ServerWebSocket;

  fetch(amount: number) : ServerWebSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  write(data: Buffer) : ServerWebSocket;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  setWriteQueueMaxSize(maxSize: number) : ServerWebSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  writeFrame(frame: WebSocketFrame) : ServerWebSocket;

  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeFinalTextFrame(text: string) : ServerWebSocket;

  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeFinalBinaryFrame(data: Buffer) : ServerWebSocket;

  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeBinaryMessage(data: Buffer) : ServerWebSocket;

  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  writeTextMessage(text: string) : ServerWebSocket;

  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : ServerWebSocket;

  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : ServerWebSocket;

  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : ServerWebSocket;

  uri() : string;

  /**
   */
  path() : string;

  /**
   */
  query() : string | null;

  /**
   * Accept the WebSocket and terminate the WebSocket handshake.
   * <p/>
   * This method should be called from the WebSocket handler to explicitly accept the WebSocket and
   * terminate the WebSocket handshake.
   */
  accept() : void;

  /**
   * Reject the WebSocket.
   * <p>
   * Calling this method from the WebSocket handler when it is first passed to you gives you the opportunity to reject
   * the WebSocket, which will cause the WebSocket handshake to fail by returning
   * a  response code.
   * <p>
   * You might use this method, if for example you only want to accept WebSockets with a particular path.
   */
  reject() : void;

  /**
   * Like {@link ServerWebSocket#reject} but with a <code>status</code>.
   */
  reject(status: number) : void;

  /**
   * Set an asynchronous result for the handshake, upon completion of the specified <code>future</code>, the
   * WebSocket will either be
   *
   * <ul>
   *   <li>accepted when the <code>future</code> succeeds with the HTTP  status code</li>
   *   <li>rejected when the <code>future</code> is succeeds with an HTTP status code different than </li>
   *   <li>rejected when the <code>future</code> fails with the HTTP status code <code>500</code></li>
   * </ul>
   *
   * The provided future might be completed by the WebSocket itself, e.g calling the {@link ServerWebSocket#close} method
   * will try to accept the handshake and close the WebSocket afterward. Thus it is advised to try to complete
   * the <code>future</code> with  or .
   * <p>
   * This method should be called from the WebSocket handler to explicitly set an asynchronous handshake.
   * <p>
   * Calling this method will override the <code>future</code> completion handler.
   */
  setHandshake(future: Future<number>, handler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Like {@link ServerWebSocket#setHandshake} but without a completion handler.
   */
  setHandshake(future: Future<number>) : void;

  /**
   * 
   *
   * <p>
   * The WebSocket handshake will be accepted when it hasn't yet been settled or when an asynchronous handshake
   * is in progress.
   */
  close() : void;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * Shared data allows you to share data safely between different parts of your application in a safe way.
 * <p>
 * Shared data provides:
 * <ul>
 *   <li>synchronous shared maps (local)</li>
 *   <li>asynchronous maps (local or cluster-wide)</li>
 *   <li>asynchronous locks (local or cluster-wide)</li>
 *   <li>asynchronous counters (local or cluster-wide)</li>
 * </ul>
 * <p>
 * <p>
 *   <strong>WARNING</strong>: In clustered mode, asynchronous maps/locks/counters rely on distributed data structures provided by the cluster manager.
 *   Beware that the latency relative to asynchronous maps/locks/counters operations can be much higher in clustered than in local mode.
 * </p>
 * Please see the documentation for more information.
 */
export abstract class SharedData {
  /**
   * Get the cluster wide map with the specified name. The map is accessible to all nodes in the cluster and data
   * put into the map from any node is visible to to any other node.
   */
  getClusterWideMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get the {@link AsyncMap} with the specified name. When clustered, the map is accessible to all nodes in the cluster
   * and data put into the map from any node is visible to to any other node.
   * <p>
   *   <strong>WARNING</strong>: In clustered mode, asynchronous shared maps rely on distributed data structures provided by the cluster manager.
   *   Beware that the latency relative to asynchronous shared maps operations can be much higher in clustered than in local mode.
   * </p>
   */
  getAsyncMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get the {@link AsyncMap} with the specified name.
   * <p>
   * When clustered, the map is <b>NOT</b> accessible to all nodes in the cluster.
   * Only the instance which created the map can put and retrieve data from this map.
   */
  getLocalAsyncMap<K, V>(name: string, resultHandler: ((res: AsyncResult<AsyncMap<K, V>>) => void) | Handler<AsyncResult<AsyncMap<K, V>>>) : void;

  /**
   * Get an asynchronous lock with the specified name. The lock will be passed to the handler when it is available.
   * <p>
   *   In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *   even from a single thread, can happen in non-sequential order.
   * </p>
   */
  getLock(name: string, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Like {@link SharedData#getLock} but specifying a timeout. If the lock is not obtained within the timeout
   * a failure will be sent to the handler.
   * <p>
   *   In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *   even from a single thread, can happen in non-sequential order.
   * </p>
   */
  getLockWithTimeout(name: string, timeout: number, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Get an asynchronous local lock with the specified name. The lock will be passed to the handler when it is available.
   * <p>
   *   In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *   even from a single thread, can happen in non-sequential order.
   * </p>
   */
  getLocalLock(name: string, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Like {@link SharedData#getLocalLock} but specifying a timeout. If the lock is not obtained within the timeout
   * a failure will be sent to the handler.
   * <p>
   *   In general lock acquision is unordered, so that sequential attempts to acquire a lock,
   *   even from a single thread, can happen in non-sequential order.
   * </p>
   */
  getLocalLockWithTimeout(name: string, timeout: number, resultHandler: ((res: AsyncResult<Lock>) => void) | Handler<AsyncResult<Lock>>) : void;

  /**
   * Get an asynchronous counter. The counter will be passed to the handler.
   */
  getCounter(name: string, resultHandler: ((res: AsyncResult<Counter>) => void) | Handler<AsyncResult<Counter>>) : void;

  /**
   * Get an asynchronous local counter. The counter will be passed to the handler.
   */
  getLocalCounter(name: string, resultHandler: ((res: AsyncResult<Counter>) => void) | Handler<AsyncResult<Counter>>) : void;

  /**
   * Return a <code>LocalMap</code> with the specific <code>name</code>.
   */
  getLocalMap<K, V>(name: string) : LocalMap<K, V>;
}

/**
 * The address of a socket, an inet socket address or a domain socket address.
 * <p/>
 * Use {@link SocketAddress#inetSocketAddress} to create an inet socket address and {@link SocketAddress#domainSocketAddress}
 * to create a domain socket address
 */
export abstract class SocketAddress {
  /**
   * Create a inet socket address, <code>host</code> must be non <code>null</code> and <code>port</code> must be between <code>0</code>
   * and <code>65536</code>.
   */
  static inetSocketAddress(port: number, host: string) : SocketAddress;

  /**
   * Create a domain socket address.
   */
  static domainSocketAddress(path: string) : SocketAddress;

  /**
   */
  host() : string;

  /**
   */
  port() : number;

  /**
   */
  path() : string;
}

/**
 * Represent a Service-Record (SRV) which was resolved for a domain.
 */
export abstract class SrvRecord {
  /**
   * Returns the priority for this service record.
   */
  priority() : number;

  /**
   * Returns the weight of this service record.
   */
  weight() : number;

  /**
   * Returns the port the service is running on.
   */
  port() : number;

  /**
   * Returns the name for the server being queried.
   */
  name() : string;

  /**
   * Returns the protocol for the service being queried (i.e. "_tcp").
   */
  protocol() : string;

  /**
   * Returns the service's name (i.e. "_http").
   */
  service() : string;

  /**
   * Returns the name of the host for the service.
   */
  target() : string | null;
}

/**
 * Base interface for a stream.
 */
export interface StreamBase {
  /**
   * Set an exception handler.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : StreamBase;
}

/**
 * A timeout stream is triggered by a timer, the {@link Handler} will be call when the timer is fired,
 * it can be once or several times depending on the nature of the timer related to this stream. The
 *  will be called after the timer handler has been called.
 * <p>
 * Pausing the timer inhibits the timer shots until the stream is resumed. Setting a null handler callback cancels
 * the timer.
 */
export abstract class TimeoutStream implements ReadStream<number> {
  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<number>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<number>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<number>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : TimeoutStream;

  handler(handler: ((res: number) => void) | Handler<number> | null | undefined) : TimeoutStream;

  pause() : TimeoutStream;

  resume() : TimeoutStream;

  fetch(amount: number) : TimeoutStream;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : TimeoutStream;

  /**
   * Cancels the timeout. Note this has the same effect as calling {@link TimeoutStream#handler} with a null
   * argument.
   */
  cancel() : void;
}

import { NetServerOptions } from './options';
import { DeploymentOptions } from './options';
import { DnsClientOptions } from './options';
import { VertxOptions } from './options';
import { HttpServerOptions } from './options';
import { HttpClientOptions } from './options';
import { DatagramSocketOptions } from './options';
import { NetClientOptions } from './options';

/**
 * The entry point into the Vert.x Core API.
 * <p>
 * You use an instance of this class for functionality including:
 * <ul>
 *   <li>Creating TCP clients and servers</li>
 *   <li>Creating HTTP clients and servers</li>
 *   <li>Creating DNS clients</li>
 *   <li>Creating Datagram sockets</li>
 *   <li>Setting and cancelling periodic and one-shot timers</li>
 *   <li>Getting a reference to the event bus API</li>
 *   <li>Getting a reference to the file system API</li>
 *   <li>Getting a reference to the shared data API</li>
 *   <li>Deploying and undeploying verticles</li>
 * </ul>
 * <p>
 * Most functionality in Vert.x core is fairly low level.
 * <p>
 * To create an instance of this class you can use the static factory methods: {@link Vertx#vertx},
 * {@link Vertx#vertx} and {@link Vertx#clusteredVertx}.
 * <p>
 * Please see the user manual for more detailed usage information.
 */
export abstract class Vertx implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Creates a non clustered instance using default options.
   */
  static vertx() : Vertx;

  /**
   * Creates a non clustered instance using the specified options
   */
  static vertx(options: VertxOptions) : Vertx;

  /**
   * Creates a clustered instance using the specified options.
   * <p>
   * The instance is created asynchronously and the resultHandler is called with the result when it is ready.
   */
  static clusteredVertx(options: VertxOptions, resultHandler: ((res: AsyncResult<Vertx>) => void) | Handler<AsyncResult<Vertx>>) : void;

  /**
   * Gets the current context
   */
  static currentContext() : Context | null;

  /**
   * Gets the current context, or creates one if there isn't one
   */
  getOrCreateContext() : Context;

  /**
   * Create a TCP/SSL server using the specified options
   */
  createNetServer(options: NetServerOptions) : NetServer;

  /**
   * Create a TCP/SSL server using default options
   */
  createNetServer() : NetServer;

  /**
   * Create a TCP/SSL client using the specified options
   */
  createNetClient(options: NetClientOptions) : NetClient;

  /**
   * Create a TCP/SSL client using default options
   */
  createNetClient() : NetClient;

  /**
   * Create an HTTP/HTTPS server using the specified options
   */
  createHttpServer(options: HttpServerOptions) : HttpServer;

  /**
   * Create an HTTP/HTTPS server using default options
   */
  createHttpServer() : HttpServer;

  /**
   * Create a HTTP/HTTPS client using the specified options
   */
  createHttpClient(options: HttpClientOptions) : HttpClient;

  /**
   * Create a HTTP/HTTPS client using default options
   */
  createHttpClient() : HttpClient;

  /**
   * Create a datagram socket using the specified options
   */
  createDatagramSocket(options: DatagramSocketOptions) : DatagramSocket;

  /**
   * Create a datagram socket using default options
   */
  createDatagramSocket() : DatagramSocket;

  /**
   * Get the filesystem object. There is a single instance of FileSystem per Vertx instance.
   */
  fileSystem() : FileSystem;

  /**
   * Get the event bus object. There is a single instance of EventBus per Vertx instance.
   */
  eventBus() : EventBus;

  /**
   * Create a DNS client to connect to a DNS server at the specified host and port, with the default query timeout (5 seconds)
   * <p/>
   */
  createDnsClient(port: number, host: string) : DnsClient;

  /**
   * Create a DNS client to connect to the DNS server configured by <a href="../../dataobjects.html#VertxOptions">VertxOptions</a>
   * <p>
   * DNS client takes the first configured resolver address provided by }
   */
  createDnsClient() : DnsClient;

  /**
   * Create a DNS client to connect to a DNS server
   */
  createDnsClient(options: DnsClientOptions) : DnsClient;

  /**
   * Get the shared data object. There is a single instance of SharedData per Vertx instance.
   */
  sharedData() : SharedData;

  /**
   * Set a one-shot timer to fire after <code>delay</code> milliseconds, at which point <code>handler</code> will be called with
   * the id of the timer.
   */
  setTimer(delay: number, handler: ((res: number) => void) | Handler<number>) : number;

  /**
   * Returns a one-shot timer as a read stream. The timer will be fired after <code>delay</code> milliseconds after
   * the  has been called.
   */
  timerStream(delay: number) : TimeoutStream;

  /**
   * Set a periodic timer to fire every <code>delay</code> milliseconds, at which point <code>handler</code> will be called with
   * the id of the timer.
   */
  setPeriodic(delay: number, handler: ((res: number) => void) | Handler<number>) : number;

  /**
   * Returns a periodic timer as a read stream. The timer will be fired every <code>delay</code> milliseconds after
   * the  has been called.
   */
  periodicStream(delay: number) : TimeoutStream;

  /**
   * Cancels the timer with the specified <code>id</code>.
   */
  cancelTimer(id: number) : boolean;

  /**
   * Puts the handler on the event queue for the current context so it will be run asynchronously ASAP after all
   * preceeding events have been handled.
   */
  runOnContext(action: ((res: void) => void) | Handler<void>) : void;

  /**
   * Stop the the Vertx instance and release any resources held by it.
   * <p>
   * The instance cannot be used after it has been closed.
   * <p>
   * The actual close is asynchronous and may not complete until after the call has returned.
   */
  close() : void;

  /**
   * Like {@link Vertx#close} but the completionHandler will be called when the close is complete
   */
  close(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Deploy a verticle instance given a name.
   * <p>
   * Given the name, Vert.x selects a  instance to use to instantiate the verticle.
   * <p>
   * For the rules on how factories are selected please consult the user manual.
   */
  deployVerticle(name: string) : void;

  /**
   * Like {@link Vertx#deployVerticle} but the completionHandler will be notified when the deployment is complete.
   * <p>
   * If the deployment is successful the result will contain a String representing the unique deployment ID of the
   * deployment.
   * <p>
   * This deployment ID can subsequently be used to undeploy the verticle.
   */
  deployVerticle(name: string, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link Vertx#deployVerticle} but <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a> are provided to configure the
   * deployment.
   */
  deployVerticle(name: string, options: DeploymentOptions) : void;

  /**
   * Like {@link Vertx#deployVerticle} but <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a> are provided to configure the
   * deployment.
   */
  deployVerticle(name: string, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Undeploy a verticle deployment.
   * <p>
   * The actual undeployment happens asynchronously and may not complete until after the method has returned.
   */
  undeploy(deploymentID: string) : void;

  /**
   * Like [#undeploy(String)] {@link Vertx} but the completionHandler will be notified when the undeployment is complete.
   */
  undeploy(deploymentID: string, completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Return a Set of deployment IDs for the currently deployed deploymentIDs.
   */
  deploymentIDs() : string[];

  /**
   * Is this Vert.x instance clustered?
   */
  isClustered() : boolean;

  /**
   * Safely execute some blocking code.
   * <p>
   * Executes the blocking code in the handler <code>blockingCodeHandler</code> using a thread from the worker pool.
   * <p>
   * When the code is complete the handler <code>resultHandler</code> will be called with the result on the original context
   * (e.g. on the original event loop of the caller).
   * <p>
   * A <code>Future</code> instance is passed into <code>blockingCodeHandler</code>. When the blocking code successfully completes,
   * the handler should call the {@link Promise#complete} or {@link Promise#complete} method, or the {@link Promise#fail}
   * method if it failed.
   * <p>
   * In the <code>blockingCodeHandler</code> the current context remains the original context and therefore any task
   * scheduled in the <code>blockingCodeHandler</code> will be executed on the this context and not on the worker thread.
   * <p>
   * The blocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations
   * or polling operations (i.e a thread that spin in a loop polling events in a blocking fashion) are precluded.
   * <p>
   * When the blocking operation lasts more than the 10 seconds, a message will be printed on the console by the
   * blocked thread checker.
   * <p>
   * Long blocking operations should use a dedicated thread managed by the application, which can interact with
   * verticles using the event-bus or {@link Context#runOnContext}
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link Vertx#executeBlocking} called with ordered = true.
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link Vertx#createSharedWorkerExecutor} but with the <a href="../../dataobjects.html#VertxOptions">VertxOptions</a> <code>poolSize</code>.
   */
  createSharedWorkerExecutor(name: string) : WorkerExecutor;

  /**
   * Like {@link Vertx#createSharedWorkerExecutor} but with the <a href="../../dataobjects.html#VertxOptions">VertxOptions</a> <code>maxExecuteTime</code>.
   */
  createSharedWorkerExecutor(name: string, poolSize: number) : WorkerExecutor;

  /**
   * Like {@link Vertx#createSharedWorkerExecutor} but with the .
   */
  createSharedWorkerExecutor(name: string, poolSize: number, maxExecuteTime: number) : WorkerExecutor;

  /**
   * Create a named worker executor, the executor should be closed when it's not needed anymore to release
   * resources.<p/>
   *
   * This method can be called mutiple times with the same <code>name</code>. Executors with the same name will share
   * the same worker pool. The worker pool size , max execute time and unit of max execute time are set when the worker pool is created and
   * won't change after.<p>
   *
   * The worker pool is released when all the {@link WorkerExecutor} sharing the same name are closed.
   */
  createSharedWorkerExecutor(name: string, poolSize: number, maxExecuteTime: number, maxExecuteTimeUnit: any) : WorkerExecutor;

  /**
   */
  isNativeTransportEnabled() : boolean;

  /**
   * Set a default exception handler for {@link Context}, set on  at creation.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : Vertx;

  /**
   * Deploy a verticle instance that you have created yourself.
   * <p>
   * Vert.x will assign the verticle a context and start the verticle.
   * <p>
   * The actual deploy happens asynchronously and may not complete until after the call has returned.
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */) : void;

  /**
   * Like {@link Vertx#deployVerticle} but the completionHandler will be notified when the deployment is complete.
   * <p>
   * If the deployment is successful the result will contain a string representing the unique deployment ID of the
   * deployment.
   * <p>
   * This deployment ID can subsequently be used to undeploy the verticle.
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link Vertx#deployVerticle} but <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a> are provided to configure the
   * deployment.
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, options: DeploymentOptions) : void;

  /**
   * Like {@link Vertx#deployVerticle} but {@link Verticle} instance is created by invoking the
   * <code>verticleSupplier</code>.
   * <p>
   * The supplier will be invoked as many times as <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a>.
   * It must not return the same instance twice.
   * <p>
   * Note that the supplier will be invoked on the caller thread.
   */
  deployVerticle(verticleSupplier: any /* java.util.function.Supplier<io.vertx.core.Verticle> */, options: DeploymentOptions) : void;

  /**
   * Like {@link Vertx#deployVerticle} but <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a> are provided to configure the
   * deployment.
   */
  deployVerticle(verticle: any /* io.vertx.core.Verticle */, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Like {@link Vertx#deployVerticle} but {@link Verticle} instance is created by
   * invoking the <code>verticleSupplier</code>.
   * <p>
   * The supplier will be invoked as many times as <a href="../../dataobjects.html#DeploymentOptions">DeploymentOptions</a>.
   * It must not return the same instance twice.
   * <p>
   * Note that the supplier will be invoked on the caller thread.
   */
  deployVerticle(verticleSupplier: any /* java.util.function.Supplier<io.vertx.core.Verticle> */, options: DeploymentOptions, completionHandler: ((res: AsyncResult<string>) => void) | Handler<AsyncResult<string>>) : void;

  /**
   * Register a <code>VerticleFactory</code> that can be used for deploying Verticles based on an identifier.
   */
  registerVerticleFactory(factory: any /* io.vertx.core.spi.VerticleFactory */) : void;

  /**
   * Unregister a <code>VerticleFactory</code>
   */
  unregisterVerticleFactory(factory: any /* io.vertx.core.spi.VerticleFactory */) : void;

  /**
   * Return the Set of currently registered verticle factories.
   */
  verticleFactories() : any /* io.vertx.core.spi.VerticleFactory */[];

  /**
   * Return the Netty EventLoopGroup used by Vert.x
   */
  nettyEventLoopGroup() : any /* io.netty.channel.EventLoopGroup */;
}

/**
 * Represents a client-side WebSocket.
 */
export abstract class WebSocket implements WebSocketBase {
  /**
   * Same as {@link WebSocketBase#end} but writes some data to the stream before ending.
   */
  end(data: Buffer) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link WebSocket#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the event bus - the ID of that
   * handler is given by this method.
   * <p>
   * Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  binaryHandlerID() : string;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the eventbus, the ID of that
   * handler is given by <code>textHandlerID</code>.
   * <p>
   * Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   * <p/>
   * On the server, the value will be <code>null</code> when the handler receives the websocket callback as the
   * handshake will not be completed yet.
   */
  subProtocol() : string;

  /**
   * Returns the close status code received from the remote endpoint or <code>null</code> when not yet received.
   */
  closeStatusCode() : number;

  /**
   * Returns the close reason message from the remote endpoint or <code>null</code> when not yet received.
   */
  closeReason() : string;

  /**
   *  Returns the HTTP headers when the WebSocket is first obtained in the handler.
   *  <p/>
   *  The headers will be <code>null</code> on subsequent interactions.
   */
  headers() : MultiMap;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no handler for ping frames because RFC 6455  clearly
   * states that the only response to a ping frame is a pong frame with identical contents.
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   * automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   * to implement a one way heartbeat.
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   * , but the buffer will be converted to a String first
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link WebSocket#handler}
   * except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   * into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal} to find the boundaries).
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   * on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   * specify whether the client or server sends a ping.
   * <p>
   * Pong frames may be at most 125 bytes (octets).
   * <p>
   * There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   * <p>
   * Pong frames may be received unsolicited.
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link WebSocketBase#close}
   */
  end() : void;

  /**
   * Calls {@link WebSocketBase#close}
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending the default close frame.
   * <p/>
   * No more messages can be sent.
   */
  close() : void;

  /**
   * Same as {@link WebSocketBase#close} but with an <code>handler</code> called when the operation completes
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link WebSocketBase#close} but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   */
  isSsl() : boolean;

  /**
   */
  isClosed() : boolean;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : WebSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocket;

  pause() : WebSocket;

  resume() : WebSocket;

  fetch(amount: number) : WebSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  write(data: Buffer) : WebSocket;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  setWriteQueueMaxSize(maxSize: number) : WebSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  writeFrame(frame: WebSocketFrame) : WebSocket;

  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeFinalTextFrame(text: string) : WebSocket;

  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeFinalBinaryFrame(data: Buffer) : WebSocket;

  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeBinaryMessage(data: Buffer) : WebSocket;

  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  writeTextMessage(text: string) : WebSocket;

  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocket;

  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocket;

  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : WebSocket;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * Base WebSocket implementation.
 * <p>
 * It implements both  and  so it can be used with
 * {@link Pipe} to pipe data with flow control.
 */
export interface WebSocketBase extends ReadStream<Buffer>, WriteStream<Buffer> {
  /**
   * Same as {@link WebSocketBase#end} but writes some data to the stream before ending.
   */
  end(data: Buffer) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link WebSocketBase#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Pause this stream and return a  to transfer the elements of this stream to a destination .
   * <p/>
   * The stream will be resumed when the pipe will be wired to a <code>WriteStream</code>.
   */
  pipe() : Pipe<Buffer>;

  /**
   * Like {@link ReadStream#pipeTo} but with no completion handler.
   */
  pipeTo(dst: WriteStream<Buffer>) : void;

  /**
   * Pipe this <code>ReadStream</code> to the <code>WriteStream</code>.
   * <p>
   * Elements emitted by this stream will be written to the write stream until this stream ends or fails.
   * <p>
   * Once this stream has ended or failed, the write stream will be ended and the <code>handler</code> will be
   * called with the result.
   */
  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : WebSocketBase;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  pause() : WebSocketBase;

  resume() : WebSocketBase;

  fetch(amount: number) : WebSocketBase;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  write(data: Buffer) : WebSocketBase;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  setWriteQueueMaxSize(maxSize: number) : WebSocketBase;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the event bus - the ID of that
   * handler is given by this method.
   * <p>
   * Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  binaryHandlerID() : string;

  /**
   * When a <code>WebSocket</code> is created it automatically registers an event handler with the eventbus, the ID of that
   * handler is given by <code>textHandlerID</code>.
   * <p>
   * Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   * allows you to write data to other WebSockets which are owned by different event loops.
   */
  textHandlerID() : string;

  /**
   * Returns the WebSocket sub protocol selected by the WebSocket handshake.
   * <p/>
   * On the server, the value will be <code>null</code> when the handler receives the websocket callback as the
   * handshake will not be completed yet.
   */
  subProtocol() : string;

  /**
   * Returns the close status code received from the remote endpoint or <code>null</code> when not yet received.
   */
  closeStatusCode() : number;

  /**
   * Returns the close reason message from the remote endpoint or <code>null</code> when not yet received.
   */
  closeReason() : string;

  /**
   *  Returns the HTTP headers when the WebSocket is first obtained in the handler.
   *  <p/>
   *  The headers will be <code>null</code> on subsequent interactions.
   */
  headers() : MultiMap;

  /**
   * Write a WebSocket frame to the connection
   */
  writeFrame(frame: WebSocketFrame) : WebSocketBase;

  /**
   * Same as {@link WebSocketBase#writeFrame} but with an <code>handler</code> called when the operation completes
   */
  writeFrame(frame: WebSocketFrame, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Write a final WebSocket text frame to the connection
   */
  writeFinalTextFrame(text: string) : WebSocketBase;

  /**
   * Same as {@link WebSocketBase#writeFinalTextFrame} but with an <code>handler</code> called when the operation completes
   */
  writeFinalTextFrame(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Write a final WebSocket binary frame to the connection
   */
  writeFinalBinaryFrame(data: Buffer) : WebSocketBase;

  /**
   * Same as {@link WebSocketBase#writeFinalBinaryFrame} but with an <code>handler</code> called when the operation completes
   */
  writeFinalBinaryFrame(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a (potentially large) piece of binary data to the connection. This data might be written as multiple frames
   * if it exceeds the maximum WebSocket frame size.
   */
  writeBinaryMessage(data: Buffer) : WebSocketBase;

  /**
   * Same as {@link WebSocketBase#writeBinaryMessage} but with an <code>handler</code> called when the operation completes
   */
  writeBinaryMessage(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a (potentially large) piece of text data to the connection. This data might be written as multiple frames
   * if it exceeds the maximum WebSocket frame size.
   */
  writeTextMessage(text: string) : WebSocketBase;

  /**
   * Same as {@link WebSocketBase#writeTextMessage} but with an <code>handler</code> called when the operation completes
   */
  writeTextMessage(text: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WebSocketBase;

  /**
   * Writes a ping frame to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 Section <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no handler for ping frames because RFC 6455  clearly
   * states that the only response to a ping frame is a pong frame with identical contents.
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   * Writes a pong frame to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   * <p>
   * This method should not be used to write application data and should only be used for implementing a keep alive or
   * to ensure the client is still responsive, see RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a>.
   * <p>
   * There is no need to manually write a pong frame, as the server and client both handle responding to a ping from with a pong from
   * automatically and this is exposed to users. RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> states that pongs may be sent unsolicited in order
   * to implement a one way heartbeat.
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   * Set a close handler. This will be called when the WebSocket is closed.
   * <p/>
   * After this callback, no more messages are expected. When the WebSocket received a close frame, the
   * {@link WebSocketBase#closeStatusCode} will return the status code and {@link WebSocketBase#closeReason} will return the reason.
   */
  closeHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WebSocketBase;

  /**
   * Set a frame handler on the connection. This handler will be called when frames are read on the connection.
   */
  frameHandler(handler: ((res: WebSocketFrame) => void) | Handler<WebSocketFrame> | null | undefined) : WebSocketBase;

  /**
   * Set a text message handler on the connection. This handler will be called similar to the
   * , but the buffer will be converted to a String first
   */
  textMessageHandler(handler: ((res: string) => void) | Handler<string> | null | undefined) : WebSocketBase;

  /**
   * Set a binary message handler on the connection. This handler serves a similar purpose to {@link WebSocketBase#handler}
   * except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   * into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal} to find the boundaries).
   */
  binaryMessageHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Set a pong frame handler on the connection.  This handler will be invoked every time a pong frame is received
   * on the server, and can be used by both clients and servers since the RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">section 5.5.2</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">section 5.5.3</a> do not
   * specify whether the client or server sends a ping.
   * <p>
   * Pong frames may be at most 125 bytes (octets).
   * <p>
   * There is no ping handler since ping frames should immediately be responded to with a pong frame with identical content
   * <p>
   * Pong frames may be received unsolicited.
   */
  pongHandler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : WebSocketBase;

  /**
   * Calls {@link WebSocketBase#close}
   */
  end() : void;

  /**
   * Calls {@link WebSocketBase#close}
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending the default close frame.
   * <p/>
   * No more messages can be sent.
   */
  close() : void;

  /**
   * Same as {@link WebSocketBase#close} but with an <code>handler</code> called when the operation completes
   */
  close(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close the WebSocket sending a close frame with specified status code. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number) : void;

  /**
   * Same as {@link WebSocketBase#close} but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads
   * here: RFC6455 <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">section 7.4.1</a>
   * <p/>
   * No more messages can be sent.
   */
  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  close(statusCode: number, reason: string | null | undefined, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   */
  remoteAddress() : SocketAddress;

  /**
   */
  localAddress() : SocketAddress;

  /**
   */
  isSsl() : boolean;

  /**
   */
  isClosed() : boolean;

  /**
   */
  sslSession() : any /* javax.net.ssl.SSLSession */;
}

/**
 * A WebSocket frame that represents either text or binary data.
 * <p>
 * A WebSocket message is composed of one or more WebSocket frames.
 * <p>
 * If there is a just a single frame in the message then a single text or binary frame should be created with final = true.
 * <p>
 * If there are more than one frames in the message, then the first frame should be a text or binary frame with
 * final = false, followed by one or more continuation frames. The last continuation frame should have final = true.
 */
export abstract class WebSocketFrame {
  /**
   * Create a binary WebSocket frame.
   */
  static binaryFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   * Create a text WebSocket frame.
   */
  static textFrame(str: string, isFinal: boolean) : WebSocketFrame;

  /**
   * Create a ping WebSocket frame.  Will be a final frame. There is no option for non final ping frames.
   */
  static pingFrame(data: Buffer) : WebSocketFrame;

  /**
   * Create a pong WebSocket frame.  Will be a final frame. There is no option for non final pong frames.
   */
  static pongFrame(data: Buffer) : WebSocketFrame;

  /**
   * Create a continuation frame
   */
  static continuationFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   */
  isText() : boolean;

  /**
   */
  isBinary() : boolean;

  /**
   */
  isContinuation() : boolean;

  /**
   */
  isClose() : boolean;

  /**
   */
  textData() : string;

  /**
   */
  binaryData() : Buffer;

  /**
   */
  isFinal() : boolean;

  /**
   */
  closeStatusCode() : number;

  /**
   */
  closeReason() : string;
}

/**
 * An executor for executing blocking code in Vert.x .<p>
 *
 * It provides the same <code>executeBlocking</code> operation than {@link Context} and
 * {@link Vertx} but on a separate worker pool.<p>
 */
export abstract class WorkerExecutor implements Measured {
  /**
   * Whether the metrics are enabled for this measured object
   */
  isMetricsEnabled() : boolean;

  /**
   * Safely execute some blocking code.
   * <p>
   * Executes the blocking code in the handler <code>blockingCodeHandler</code> using a thread from the worker pool.
   * <p>
   * When the code is complete the handler <code>resultHandler</code> will be called with the result on the original context
   * (i.e. on the original event loop of the caller).
   * <p>
   * A <code>Future</code> instance is passed into <code>blockingCodeHandler</code>. When the blocking code successfully completes,
   * the handler should call the {@link Promise#complete} or {@link Promise#complete} method, or the {@link Promise#fail}
   * method if it failed.
   * <p>
   * In the <code>blockingCodeHandler</code> the current context remains the original context and therefore any task
   * scheduled in the <code>blockingCodeHandler</code> will be executed on the this context and not on the worker thread.
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, ordered: boolean, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Like {@link WorkerExecutor#executeBlocking} called with ordered = true.
   */
  executeBlocking<T>(blockingCodeHandler: ((res: Promise<T>) => void) | Handler<Promise<T>>, resultHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Close the executor.
   */
  close() : void;
}

/**
 *
 * Represents a stream of data that can be written to.
 * <p>
 * Any class that implements this interface can be used by a {@link Pipe} to pipe data from a <code>ReadStream</code>
 * to it.
 */
export interface WriteStream<T> extends StreamBase {
  /**
   * Set an exception handler on the write stream.
   */
  exceptionHandler(handler: ((res: Throwable) => void) | Handler<Throwable> | null | undefined) : WriteStream<T>;

  /**
   * Write some data to the stream. The data is put on an internal write queue, and the write actually happens
   * asynchronously. To avoid running out of memory by putting too much on the write queue,
   * check the {@link WriteStream#writeQueueFull} method before writing. This is done automatically if using a {@link Pump}.
   */
  write(data: T) : WriteStream<T>;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  write(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : WriteStream<T>;

  /**
   * Ends the stream.
   * <p>
   * Once the stream has ended, it cannot be used any more.
   */
  end() : void;

  /**
   * Same as {@link WriteStream#end} but with an <code>handler</code> called when the operation completes
   */
  end(handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Same as {@link WriteStream#end} but writes some data to the stream before ending.
   */
  end(data: T) : void;

  /**
   * Same as  but with an <code>handler</code> called when the operation completes
   */
  end(data: T, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Set the maximum size of the write queue to <code>maxSize</code>. You will still be able to write to the stream even
   * if there is more than <code>maxSize</code> items in the write queue. This is used as an indicator by classes such as
   * <code>Pump</code> to provide flow control.
   * <p/>
   * The value is defined by the implementation of the stream, e.g in bytes for a
   * {@link NetSocket}, the number of {@link Message} for a
   * {@link MessageProducer}, etc...
   */
  setWriteQueueMaxSize(maxSize: number) : WriteStream<T>;

  /**
   * This will return <code>true</code> if there are more bytes in the write queue than the value set using {@link WriteStream#setWriteQueueMaxSize}
   */
  writeQueueFull() : boolean;

  /**
   * Set a drain handler on the stream. If the write queue is full, then the handler will be called when the write
   * queue is ready to accept buffers again. See {@link Pump} for an example of this being used.
   * <p/>
   * The stream implementation defines when the drain handler, for example it could be when the queue size has been
   * reduced to <code>maxSize / 2</code>.
   */
  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : WriteStream<T>;
}
